module.exports = {

"[project]/node_modules/sweetalert2/dist/sweetalert2.esm.all.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*!
* sweetalert2 v11.21.0
* Released under the MIT License.
*/ __turbopack_context__.s({
    "default": (()=>Swal)
});
function _assertClassBrand(e, t, n) {
    if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
    throw new TypeError("Private element is not present on this object");
}
function _checkPrivateRedeclaration(e, t) {
    if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateFieldGet2(s, a) {
    return s.get(_assertClassBrand(s, a));
}
function _classPrivateFieldInitSpec(e, t, a) {
    _checkPrivateRedeclaration(e, t), t.set(e, a);
}
function _classPrivateFieldSet2(s, a, r) {
    return s.set(_assertClassBrand(s, a), r), r;
}
const RESTORE_FOCUS_TIMEOUT = 100;
/** @type {GlobalState} */ const globalState = {};
const focusPreviousActiveElement = ()=>{
    if (globalState.previousActiveElement instanceof HTMLElement) {
        globalState.previousActiveElement.focus();
        globalState.previousActiveElement = null;
    } else if (document.body) {
        document.body.focus();
    }
};
/**
 * Restore previous active (focused) element
 *
 * @param {boolean} returnFocus
 * @returns {Promise<void>}
 */ const restoreActiveElement = (returnFocus)=>{
    return new Promise((resolve)=>{
        if (!returnFocus) {
            return resolve();
        }
        const x = window.scrollX;
        const y = window.scrollY;
        globalState.restoreFocusTimeout = setTimeout(()=>{
            focusPreviousActiveElement();
            resolve();
        }, RESTORE_FOCUS_TIMEOUT); // issues/900
        window.scrollTo(x, y);
    });
};
const swalPrefix = 'swal2-';
/**
 * @typedef {Record<SwalClass, string>} SwalClasses
 */ /**
 * @typedef {'success' | 'warning' | 'info' | 'question' | 'error'} SwalIcon
 * @typedef {Record<SwalIcon, string>} SwalIcons
 */ /** @type {SwalClass[]} */ const classNames = [
    'container',
    'shown',
    'height-auto',
    'iosfix',
    'popup',
    'modal',
    'no-backdrop',
    'no-transition',
    'toast',
    'toast-shown',
    'show',
    'hide',
    'close',
    'title',
    'html-container',
    'actions',
    'confirm',
    'deny',
    'cancel',
    'footer',
    'icon',
    'icon-content',
    'image',
    'input',
    'file',
    'range',
    'select',
    'radio',
    'checkbox',
    'label',
    'textarea',
    'inputerror',
    'input-label',
    'validation-message',
    'progress-steps',
    'active-progress-step',
    'progress-step',
    'progress-step-line',
    'loader',
    'loading',
    'styled',
    'top',
    'top-start',
    'top-end',
    'top-left',
    'top-right',
    'center',
    'center-start',
    'center-end',
    'center-left',
    'center-right',
    'bottom',
    'bottom-start',
    'bottom-end',
    'bottom-left',
    'bottom-right',
    'grow-row',
    'grow-column',
    'grow-fullscreen',
    'rtl',
    'timer-progress-bar',
    'timer-progress-bar-container',
    'scrollbar-measure',
    'icon-success',
    'icon-warning',
    'icon-info',
    'icon-question',
    'icon-error',
    'draggable',
    'dragging'
];
const swalClasses = classNames.reduce((acc, className)=>{
    acc[className] = swalPrefix + className;
    return acc;
}, /** @type {SwalClasses} */ {});
/** @type {SwalIcon[]} */ const icons = [
    'success',
    'warning',
    'info',
    'question',
    'error'
];
const iconTypes = icons.reduce((acc, icon)=>{
    acc[icon] = swalPrefix + icon;
    return acc;
}, /** @type {SwalIcons} */ {});
const consolePrefix = 'SweetAlert2:';
/**
 * Capitalize the first letter of a string
 *
 * @param {string} str
 * @returns {string}
 */ const capitalizeFirstLetter = (str)=>str.charAt(0).toUpperCase() + str.slice(1);
/**
 * Standardize console warnings
 *
 * @param {string | string[]} message
 */ const warn = (message)=>{
    console.warn(`${consolePrefix} ${typeof message === 'object' ? message.join(' ') : message}`);
};
/**
 * Standardize console errors
 *
 * @param {string} message
 */ const error = (message)=>{
    console.error(`${consolePrefix} ${message}`);
};
/**
 * Private global state for `warnOnce`
 *
 * @type {string[]}
 * @private
 */ const previousWarnOnceMessages = [];
/**
 * Show a console warning, but only if it hasn't already been shown
 *
 * @param {string} message
 */ const warnOnce = (message)=>{
    if (!previousWarnOnceMessages.includes(message)) {
        previousWarnOnceMessages.push(message);
        warn(message);
    }
};
/**
 * Show a one-time console warning about deprecated params/methods
 *
 * @param {string} deprecatedParam
 * @param {string?} useInstead
 */ const warnAboutDeprecation = function(deprecatedParam) {
    let useInstead = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    warnOnce(`"${deprecatedParam}" is deprecated and will be removed in the next major release.${useInstead ? ` Use "${useInstead}" instead.` : ''}`);
};
/**
 * If `arg` is a function, call it (with no arguments or context) and return the result.
 * Otherwise, just pass the value through
 *
 * @param {Function | any} arg
 * @returns {any}
 */ const callIfFunction = (arg)=>typeof arg === 'function' ? arg() : arg;
/**
 * @param {any} arg
 * @returns {boolean}
 */ const hasToPromiseFn = (arg)=>arg && typeof arg.toPromise === 'function';
/**
 * @param {any} arg
 * @returns {Promise<any>}
 */ const asPromise = (arg)=>hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);
/**
 * @param {any} arg
 * @returns {boolean}
 */ const isPromise = (arg)=>arg && Promise.resolve(arg) === arg;
/**
 * Gets the popup container which contains the backdrop and the popup itself.
 *
 * @returns {HTMLElement | null}
 */ const getContainer = ()=>document.body.querySelector(`.${swalClasses.container}`);
/**
 * @param {string} selectorString
 * @returns {HTMLElement | null}
 */ const elementBySelector = (selectorString)=>{
    const container = getContainer();
    return container ? container.querySelector(selectorString) : null;
};
/**
 * @param {string} className
 * @returns {HTMLElement | null}
 */ const elementByClass = (className)=>{
    return elementBySelector(`.${className}`);
};
/**
 * @returns {HTMLElement | null}
 */ const getPopup = ()=>elementByClass(swalClasses.popup);
/**
 * @returns {HTMLElement | null}
 */ const getIcon = ()=>elementByClass(swalClasses.icon);
/**
 * @returns {HTMLElement | null}
 */ const getIconContent = ()=>elementByClass(swalClasses['icon-content']);
/**
 * @returns {HTMLElement | null}
 */ const getTitle = ()=>elementByClass(swalClasses.title);
/**
 * @returns {HTMLElement | null}
 */ const getHtmlContainer = ()=>elementByClass(swalClasses['html-container']);
/**
 * @returns {HTMLElement | null}
 */ const getImage = ()=>elementByClass(swalClasses.image);
/**
 * @returns {HTMLElement | null}
 */ const getProgressSteps = ()=>elementByClass(swalClasses['progress-steps']);
/**
 * @returns {HTMLElement | null}
 */ const getValidationMessage = ()=>elementByClass(swalClasses['validation-message']);
/**
 * @returns {HTMLButtonElement | null}
 */ const getConfirmButton = ()=>/** @type {HTMLButtonElement} */ elementBySelector(`.${swalClasses.actions} .${swalClasses.confirm}`);
/**
 * @returns {HTMLButtonElement | null}
 */ const getCancelButton = ()=>/** @type {HTMLButtonElement} */ elementBySelector(`.${swalClasses.actions} .${swalClasses.cancel}`);
/**
 * @returns {HTMLButtonElement | null}
 */ const getDenyButton = ()=>/** @type {HTMLButtonElement} */ elementBySelector(`.${swalClasses.actions} .${swalClasses.deny}`);
/**
 * @returns {HTMLElement | null}
 */ const getInputLabel = ()=>elementByClass(swalClasses['input-label']);
/**
 * @returns {HTMLElement | null}
 */ const getLoader = ()=>elementBySelector(`.${swalClasses.loader}`);
/**
 * @returns {HTMLElement | null}
 */ const getActions = ()=>elementByClass(swalClasses.actions);
/**
 * @returns {HTMLElement | null}
 */ const getFooter = ()=>elementByClass(swalClasses.footer);
/**
 * @returns {HTMLElement | null}
 */ const getTimerProgressBar = ()=>elementByClass(swalClasses['timer-progress-bar']);
/**
 * @returns {HTMLElement | null}
 */ const getCloseButton = ()=>elementByClass(swalClasses.close);
// https://github.com/jkup/focusable/blob/master/index.js
const focusable = `
  a[href],
  area[href],
  input:not([disabled]),
  select:not([disabled]),
  textarea:not([disabled]),
  button:not([disabled]),
  iframe,
  object,
  embed,
  [tabindex="0"],
  [contenteditable],
  audio[controls],
  video[controls],
  summary
`;
/**
 * @returns {HTMLElement[]}
 */ const getFocusableElements = ()=>{
    const popup = getPopup();
    if (!popup) {
        return [];
    }
    /** @type {NodeListOf<HTMLElement>} */ const focusableElementsWithTabindex = popup.querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])');
    const focusableElementsWithTabindexSorted = Array.from(focusableElementsWithTabindex)// sort according to tabindex
    .sort((a, b)=>{
        const tabindexA = parseInt(a.getAttribute('tabindex') || '0');
        const tabindexB = parseInt(b.getAttribute('tabindex') || '0');
        if (tabindexA > tabindexB) {
            return 1;
        } else if (tabindexA < tabindexB) {
            return -1;
        }
        return 0;
    });
    /** @type {NodeListOf<HTMLElement>} */ const otherFocusableElements = popup.querySelectorAll(focusable);
    const otherFocusableElementsFiltered = Array.from(otherFocusableElements).filter((el)=>el.getAttribute('tabindex') !== '-1');
    return [
        ...new Set(focusableElementsWithTabindexSorted.concat(otherFocusableElementsFiltered))
    ].filter((el)=>isVisible$1(el));
};
/**
 * @returns {boolean}
 */ const isModal = ()=>{
    return hasClass(document.body, swalClasses.shown) && !hasClass(document.body, swalClasses['toast-shown']) && !hasClass(document.body, swalClasses['no-backdrop']);
};
/**
 * @returns {boolean}
 */ const isToast = ()=>{
    const popup = getPopup();
    if (!popup) {
        return false;
    }
    return hasClass(popup, swalClasses.toast);
};
/**
 * @returns {boolean}
 */ const isLoading = ()=>{
    const popup = getPopup();
    if (!popup) {
        return false;
    }
    return popup.hasAttribute('data-loading');
};
/**
 * Securely set innerHTML of an element
 * https://github.com/sweetalert2/sweetalert2/issues/1926
 *
 * @param {HTMLElement} elem
 * @param {string} html
 */ const setInnerHtml = (elem, html)=>{
    elem.textContent = '';
    if (html) {
        const parser = new DOMParser();
        const parsed = parser.parseFromString(html, `text/html`);
        const head = parsed.querySelector('head');
        if (head) {
            Array.from(head.childNodes).forEach((child)=>{
                elem.appendChild(child);
            });
        }
        const body = parsed.querySelector('body');
        if (body) {
            Array.from(body.childNodes).forEach((child)=>{
                if (child instanceof HTMLVideoElement || child instanceof HTMLAudioElement) {
                    elem.appendChild(child.cloneNode(true)); // https://github.com/sweetalert2/sweetalert2/issues/2507
                } else {
                    elem.appendChild(child);
                }
            });
        }
    }
};
/**
 * @param {HTMLElement} elem
 * @param {string} className
 * @returns {boolean}
 */ const hasClass = (elem, className)=>{
    if (!className) {
        return false;
    }
    const classList = className.split(/\s+/);
    for(let i = 0; i < classList.length; i++){
        if (!elem.classList.contains(classList[i])) {
            return false;
        }
    }
    return true;
};
/**
 * @param {HTMLElement} elem
 * @param {SweetAlertOptions} params
 */ const removeCustomClasses = (elem, params)=>{
    Array.from(elem.classList).forEach((className)=>{
        if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass || {}).includes(className)) {
            elem.classList.remove(className);
        }
    });
};
/**
 * @param {HTMLElement} elem
 * @param {SweetAlertOptions} params
 * @param {string} className
 */ const applyCustomClass = (elem, params, className)=>{
    removeCustomClasses(elem, params);
    if (!params.customClass) {
        return;
    }
    const customClass = params.customClass[/** @type {keyof SweetAlertCustomClass} */ className];
    if (!customClass) {
        return;
    }
    if (typeof customClass !== 'string' && !customClass.forEach) {
        warn(`Invalid type of customClass.${className}! Expected string or iterable object, got "${typeof customClass}"`);
        return;
    }
    addClass(elem, customClass);
};
/**
 * @param {HTMLElement} popup
 * @param {import('./renderers/renderInput').InputClass | SweetAlertInput} inputClass
 * @returns {HTMLInputElement | null}
 */ const getInput$1 = (popup, inputClass)=>{
    if (!inputClass) {
        return null;
    }
    switch(inputClass){
        case 'select':
        case 'textarea':
        case 'file':
            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses[inputClass]}`);
        case 'checkbox':
            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.checkbox} input`);
        case 'radio':
            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:checked`) || popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:first-child`);
        case 'range':
            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.range} input`);
        default:
            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.input}`);
    }
};
/**
 * @param {HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement} input
 */ const focusInput = (input)=>{
    input.focus();
    // place cursor at end of text in text input
    if (input.type !== 'file') {
        // http://stackoverflow.com/a/2345915
        const val = input.value;
        input.value = '';
        input.value = val;
    }
};
/**
 * @param {HTMLElement | HTMLElement[] | null} target
 * @param {string | string[] | readonly string[] | undefined} classList
 * @param {boolean} condition
 */ const toggleClass = (target, classList, condition)=>{
    if (!target || !classList) {
        return;
    }
    if (typeof classList === 'string') {
        classList = classList.split(/\s+/).filter(Boolean);
    }
    classList.forEach((className)=>{
        if (Array.isArray(target)) {
            target.forEach((elem)=>{
                if (condition) {
                    elem.classList.add(className);
                } else {
                    elem.classList.remove(className);
                }
            });
        } else {
            if (condition) {
                target.classList.add(className);
            } else {
                target.classList.remove(className);
            }
        }
    });
};
/**
 * @param {HTMLElement | HTMLElement[] | null} target
 * @param {string | string[] | readonly string[] | undefined} classList
 */ const addClass = (target, classList)=>{
    toggleClass(target, classList, true);
};
/**
 * @param {HTMLElement | HTMLElement[] | null} target
 * @param {string | string[] | readonly string[] | undefined} classList
 */ const removeClass = (target, classList)=>{
    toggleClass(target, classList, false);
};
/**
 * Get direct child of an element by class name
 *
 * @param {HTMLElement} elem
 * @param {string} className
 * @returns {HTMLElement | undefined}
 */ const getDirectChildByClass = (elem, className)=>{
    const children = Array.from(elem.children);
    for(let i = 0; i < children.length; i++){
        const child = children[i];
        if (child instanceof HTMLElement && hasClass(child, className)) {
            return child;
        }
    }
};
/**
 * @param {HTMLElement} elem
 * @param {string} property
 * @param {*} value
 */ const applyNumericalStyle = (elem, property, value)=>{
    if (value === `${parseInt(value)}`) {
        value = parseInt(value);
    }
    if (value || parseInt(value) === 0) {
        elem.style.setProperty(property, typeof value === 'number' ? `${value}px` : value);
    } else {
        elem.style.removeProperty(property);
    }
};
/**
 * @param {HTMLElement | null} elem
 * @param {string} display
 */ const show = function(elem) {
    let display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'flex';
    if (!elem) {
        return;
    }
    elem.style.display = display;
};
/**
 * @param {HTMLElement | null} elem
 */ const hide = (elem)=>{
    if (!elem) {
        return;
    }
    elem.style.display = 'none';
};
/**
 * @param {HTMLElement | null} elem
 * @param {string} display
 */ const showWhenInnerHtmlPresent = function(elem) {
    let display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'block';
    if (!elem) {
        return;
    }
    new MutationObserver(()=>{
        toggle(elem, elem.innerHTML, display);
    }).observe(elem, {
        childList: true,
        subtree: true
    });
};
/**
 * @param {HTMLElement} parent
 * @param {string} selector
 * @param {string} property
 * @param {string} value
 */ const setStyle = (parent, selector, property, value)=>{
    /** @type {HTMLElement | null} */ const el = parent.querySelector(selector);
    if (el) {
        el.style.setProperty(property, value);
    }
};
/**
 * @param {HTMLElement} elem
 * @param {any} condition
 * @param {string} display
 */ const toggle = function(elem, condition) {
    let display = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'flex';
    if (condition) {
        show(elem, display);
    } else {
        hide(elem);
    }
};
/**
 * borrowed from jquery $(elem).is(':visible') implementation
 *
 * @param {HTMLElement | null} elem
 * @returns {boolean}
 */ const isVisible$1 = (elem)=>!!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));
/**
 * @returns {boolean}
 */ const allButtonsAreHidden = ()=>!isVisible$1(getConfirmButton()) && !isVisible$1(getDenyButton()) && !isVisible$1(getCancelButton());
/**
 * @param {HTMLElement} elem
 * @returns {boolean}
 */ const isScrollable = (elem)=>!!(elem.scrollHeight > elem.clientHeight);
/**
 * borrowed from https://stackoverflow.com/a/46352119
 *
 * @param {HTMLElement} elem
 * @returns {boolean}
 */ const hasCssAnimation = (elem)=>{
    const style = window.getComputedStyle(elem);
    const animDuration = parseFloat(style.getPropertyValue('animation-duration') || '0');
    const transDuration = parseFloat(style.getPropertyValue('transition-duration') || '0');
    return animDuration > 0 || transDuration > 0;
};
/**
 * @param {number} timer
 * @param {boolean} reset
 */ const animateTimerProgressBar = function(timer) {
    let reset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    const timerProgressBar = getTimerProgressBar();
    if (!timerProgressBar) {
        return;
    }
    if (isVisible$1(timerProgressBar)) {
        if (reset) {
            timerProgressBar.style.transition = 'none';
            timerProgressBar.style.width = '100%';
        }
        setTimeout(()=>{
            timerProgressBar.style.transition = `width ${timer / 1000}s linear`;
            timerProgressBar.style.width = '0%';
        }, 10);
    }
};
const stopTimerProgressBar = ()=>{
    const timerProgressBar = getTimerProgressBar();
    if (!timerProgressBar) {
        return;
    }
    const timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
    timerProgressBar.style.removeProperty('transition');
    timerProgressBar.style.width = '100%';
    const timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
    const timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;
    timerProgressBar.style.width = `${timerProgressBarPercent}%`;
};
/**
 * Detect Node env
 *
 * @returns {boolean}
 */ const isNodeEnv = ()=>typeof window === 'undefined' || typeof document === 'undefined';
const sweetHTML = `
 <div aria-labelledby="${swalClasses.title}" aria-describedby="${swalClasses['html-container']}" class="${swalClasses.popup}" tabindex="-1">
   <button type="button" class="${swalClasses.close}"></button>
   <ul class="${swalClasses['progress-steps']}"></ul>
   <div class="${swalClasses.icon}"></div>
   <img class="${swalClasses.image}" />
   <h2 class="${swalClasses.title}" id="${swalClasses.title}"></h2>
   <div class="${swalClasses['html-container']}" id="${swalClasses['html-container']}"></div>
   <input class="${swalClasses.input}" id="${swalClasses.input}" />
   <input type="file" class="${swalClasses.file}" />
   <div class="${swalClasses.range}">
     <input type="range" />
     <output></output>
   </div>
   <select class="${swalClasses.select}" id="${swalClasses.select}"></select>
   <div class="${swalClasses.radio}"></div>
   <label class="${swalClasses.checkbox}">
     <input type="checkbox" id="${swalClasses.checkbox}" />
     <span class="${swalClasses.label}"></span>
   </label>
   <textarea class="${swalClasses.textarea}" id="${swalClasses.textarea}"></textarea>
   <div class="${swalClasses['validation-message']}" id="${swalClasses['validation-message']}"></div>
   <div class="${swalClasses.actions}">
     <div class="${swalClasses.loader}"></div>
     <button type="button" class="${swalClasses.confirm}"></button>
     <button type="button" class="${swalClasses.deny}"></button>
     <button type="button" class="${swalClasses.cancel}"></button>
   </div>
   <div class="${swalClasses.footer}"></div>
   <div class="${swalClasses['timer-progress-bar-container']}">
     <div class="${swalClasses['timer-progress-bar']}"></div>
   </div>
 </div>
`.replace(/(^|\n)\s*/g, '');
/**
 * @returns {boolean}
 */ const resetOldContainer = ()=>{
    const oldContainer = getContainer();
    if (!oldContainer) {
        return false;
    }
    oldContainer.remove();
    removeClass([
        document.documentElement,
        document.body
    ], [
        swalClasses['no-backdrop'],
        swalClasses['toast-shown'],
        swalClasses['has-column']
    ]);
    return true;
};
const resetValidationMessage$1 = ()=>{
    globalState.currentInstance.resetValidationMessage();
};
const addInputChangeListeners = ()=>{
    const popup = getPopup();
    const input = getDirectChildByClass(popup, swalClasses.input);
    const file = getDirectChildByClass(popup, swalClasses.file);
    /** @type {HTMLInputElement} */ const range = popup.querySelector(`.${swalClasses.range} input`);
    /** @type {HTMLOutputElement} */ const rangeOutput = popup.querySelector(`.${swalClasses.range} output`);
    const select = getDirectChildByClass(popup, swalClasses.select);
    /** @type {HTMLInputElement} */ const checkbox = popup.querySelector(`.${swalClasses.checkbox} input`);
    const textarea = getDirectChildByClass(popup, swalClasses.textarea);
    input.oninput = resetValidationMessage$1;
    file.onchange = resetValidationMessage$1;
    select.onchange = resetValidationMessage$1;
    checkbox.onchange = resetValidationMessage$1;
    textarea.oninput = resetValidationMessage$1;
    range.oninput = ()=>{
        resetValidationMessage$1();
        rangeOutput.value = range.value;
    };
    range.onchange = ()=>{
        resetValidationMessage$1();
        rangeOutput.value = range.value;
    };
};
/**
 * @param {string | HTMLElement} target
 * @returns {HTMLElement}
 */ const getTarget = (target)=>typeof target === 'string' ? document.querySelector(target) : target;
/**
 * @param {SweetAlertOptions} params
 */ const setupAccessibility = (params)=>{
    const popup = getPopup();
    popup.setAttribute('role', params.toast ? 'alert' : 'dialog');
    popup.setAttribute('aria-live', params.toast ? 'polite' : 'assertive');
    if (!params.toast) {
        popup.setAttribute('aria-modal', 'true');
    }
};
/**
 * @param {HTMLElement} targetElement
 */ const setupRTL = (targetElement)=>{
    if (window.getComputedStyle(targetElement).direction === 'rtl') {
        addClass(getContainer(), swalClasses.rtl);
    }
};
/**
 * Add modal + backdrop + no-war message for Russians to DOM
 *
 * @param {SweetAlertOptions} params
 */ const init = (params)=>{
    // Clean up the old popup container if it exists
    const oldContainerExisted = resetOldContainer();
    if (isNodeEnv()) {
        error('SweetAlert2 requires document to initialize');
        return;
    }
    const container = document.createElement('div');
    container.className = swalClasses.container;
    if (oldContainerExisted) {
        addClass(container, swalClasses['no-transition']);
    }
    setInnerHtml(container, sweetHTML);
    container.dataset['swal2Theme'] = params.theme;
    const targetElement = getTarget(params.target);
    targetElement.appendChild(container);
    if (params.topLayer) {
        container.setAttribute('popover', '');
        container.showPopover();
    }
    setupAccessibility(params);
    setupRTL(targetElement);
    addInputChangeListeners();
};
/**
 * @param {HTMLElement | object | string} param
 * @param {HTMLElement} target
 */ const parseHtmlToContainer = (param, target)=>{
    // DOM element
    if (param instanceof HTMLElement) {
        target.appendChild(param);
    } else if (typeof param === 'object') {
        handleObject(param, target);
    } else if (param) {
        setInnerHtml(target, param);
    }
};
/**
 * @param {any} param
 * @param {HTMLElement} target
 */ const handleObject = (param, target)=>{
    // JQuery element(s)
    if (param.jquery) {
        handleJqueryElem(target, param);
    } else {
        setInnerHtml(target, param.toString());
    }
};
/**
 * @param {HTMLElement} target
 * @param {any} elem
 */ const handleJqueryElem = (target, elem)=>{
    target.textContent = '';
    if (0 in elem) {
        for(let i = 0; i in elem; i++){
            target.appendChild(elem[i].cloneNode(true));
        }
    } else {
        target.appendChild(elem.cloneNode(true));
    }
};
/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */ const renderActions = (instance, params)=>{
    const actions = getActions();
    const loader = getLoader();
    if (!actions || !loader) {
        return;
    }
    // Actions (buttons) wrapper
    if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {
        hide(actions);
    } else {
        show(actions);
    }
    // Custom class
    applyCustomClass(actions, params, 'actions');
    // Render all the buttons
    renderButtons(actions, loader, params);
    // Loader
    setInnerHtml(loader, params.loaderHtml || '');
    applyCustomClass(loader, params, 'loader');
};
/**
 * @param {HTMLElement} actions
 * @param {HTMLElement} loader
 * @param {SweetAlertOptions} params
 */ function renderButtons(actions, loader, params) {
    const confirmButton = getConfirmButton();
    const denyButton = getDenyButton();
    const cancelButton = getCancelButton();
    if (!confirmButton || !denyButton || !cancelButton) {
        return;
    }
    // Render buttons
    renderButton(confirmButton, 'confirm', params);
    renderButton(denyButton, 'deny', params);
    renderButton(cancelButton, 'cancel', params);
    handleButtonsStyling(confirmButton, denyButton, cancelButton, params);
    if (params.reverseButtons) {
        if (params.toast) {
            actions.insertBefore(cancelButton, confirmButton);
            actions.insertBefore(denyButton, confirmButton);
        } else {
            actions.insertBefore(cancelButton, loader);
            actions.insertBefore(denyButton, loader);
            actions.insertBefore(confirmButton, loader);
        }
    }
}
/**
 * @param {HTMLElement} confirmButton
 * @param {HTMLElement} denyButton
 * @param {HTMLElement} cancelButton
 * @param {SweetAlertOptions} params
 */ function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {
    if (!params.buttonsStyling) {
        removeClass([
            confirmButton,
            denyButton,
            cancelButton
        ], swalClasses.styled);
        return;
    }
    addClass([
        confirmButton,
        denyButton,
        cancelButton
    ], swalClasses.styled);
    // Apply custom background colors to action buttons
    if (params.confirmButtonColor) {
        confirmButton.style.setProperty('--swal2-confirm-button-background-color', params.confirmButtonColor);
    }
    if (params.denyButtonColor) {
        denyButton.style.setProperty('--swal2-deny-button-background-color', params.denyButtonColor);
    }
    if (params.cancelButtonColor) {
        cancelButton.style.setProperty('--swal2-cancel-button-background-color', params.cancelButtonColor);
    }
    // Apply the outline color to action buttons
    applyOutlineColor(confirmButton);
    applyOutlineColor(denyButton);
    applyOutlineColor(cancelButton);
}
/**
 * @param {HTMLElement} button
 */ function applyOutlineColor(button) {
    const buttonStyle = window.getComputedStyle(button);
    const outlineColor = buttonStyle.backgroundColor.replace(/rgba?\((\d+), (\d+), (\d+).*/, 'rgba($1, $2, $3, 0.5)');
    button.style.setProperty('--swal2-action-button-outline', buttonStyle.getPropertyValue('--swal2-outline').replace(/ rgba\(.*/, ` ${outlineColor}`));
}
/**
 * @param {HTMLElement} button
 * @param {'confirm' | 'deny' | 'cancel'} buttonType
 * @param {SweetAlertOptions} params
 */ function renderButton(button, buttonType, params) {
    const buttonName = /** @type {'Confirm' | 'Deny' | 'Cancel'} */ capitalizeFirstLetter(buttonType);
    toggle(button, params[`show${buttonName}Button`], 'inline-block');
    setInnerHtml(button, params[`${buttonType}ButtonText`] || ''); // Set caption text
    button.setAttribute('aria-label', params[`${buttonType}ButtonAriaLabel`] || ''); // ARIA label
    // Add buttons custom classes
    button.className = swalClasses[buttonType];
    applyCustomClass(button, params, `${buttonType}Button`);
}
/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */ const renderCloseButton = (instance, params)=>{
    const closeButton = getCloseButton();
    if (!closeButton) {
        return;
    }
    setInnerHtml(closeButton, params.closeButtonHtml || '');
    // Custom class
    applyCustomClass(closeButton, params, 'closeButton');
    toggle(closeButton, params.showCloseButton);
    closeButton.setAttribute('aria-label', params.closeButtonAriaLabel || '');
};
/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */ const renderContainer = (instance, params)=>{
    const container = getContainer();
    if (!container) {
        return;
    }
    handleBackdropParam(container, params.backdrop);
    handlePositionParam(container, params.position);
    handleGrowParam(container, params.grow);
    // Custom class
    applyCustomClass(container, params, 'container');
};
/**
 * @param {HTMLElement} container
 * @param {SweetAlertOptions['backdrop']} backdrop
 */ function handleBackdropParam(container, backdrop) {
    if (typeof backdrop === 'string') {
        container.style.background = backdrop;
    } else if (!backdrop) {
        addClass([
            document.documentElement,
            document.body
        ], swalClasses['no-backdrop']);
    }
}
/**
 * @param {HTMLElement} container
 * @param {SweetAlertOptions['position']} position
 */ function handlePositionParam(container, position) {
    if (!position) {
        return;
    }
    if (position in swalClasses) {
        addClass(container, swalClasses[position]);
    } else {
        warn('The "position" parameter is not valid, defaulting to "center"');
        addClass(container, swalClasses.center);
    }
}
/**
 * @param {HTMLElement} container
 * @param {SweetAlertOptions['grow']} grow
 */ function handleGrowParam(container, grow) {
    if (!grow) {
        return;
    }
    addClass(container, swalClasses[`grow-${grow}`]);
}
/**
 * This module contains `WeakMap`s for each effectively-"private  property" that a `Swal` has.
 * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
 * This is the approach that Babel will probably take to implement private methods/fields
 *   https://github.com/tc39/proposal-private-methods
 *   https://github.com/babel/babel/pull/7555
 * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
 *   then we can use that language feature.
 */ var privateProps = {
    innerParams: new WeakMap(),
    domCache: new WeakMap()
};
/// <reference path="../../../../sweetalert2.d.ts"/>
/** @type {InputClass[]} */ const inputClasses = [
    'input',
    'file',
    'range',
    'select',
    'radio',
    'checkbox',
    'textarea'
];
/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */ const renderInput = (instance, params)=>{
    const popup = getPopup();
    if (!popup) {
        return;
    }
    const innerParams = privateProps.innerParams.get(instance);
    const rerender = !innerParams || params.input !== innerParams.input;
    inputClasses.forEach((inputClass)=>{
        const inputContainer = getDirectChildByClass(popup, swalClasses[inputClass]);
        if (!inputContainer) {
            return;
        }
        // set attributes
        setAttributes(inputClass, params.inputAttributes);
        // set class
        inputContainer.className = swalClasses[inputClass];
        if (rerender) {
            hide(inputContainer);
        }
    });
    if (params.input) {
        if (rerender) {
            showInput(params);
        }
        // set custom class
        setCustomClass(params);
    }
};
/**
 * @param {SweetAlertOptions} params
 */ const showInput = (params)=>{
    if (!params.input) {
        return;
    }
    if (!renderInputType[params.input]) {
        error(`Unexpected type of input! Expected ${Object.keys(renderInputType).join(' | ')}, got "${params.input}"`);
        return;
    }
    const inputContainer = getInputContainer(params.input);
    if (!inputContainer) {
        return;
    }
    const input = renderInputType[params.input](inputContainer, params);
    show(inputContainer);
    // input autofocus
    if (params.inputAutoFocus) {
        setTimeout(()=>{
            focusInput(input);
        });
    }
};
/**
 * @param {HTMLInputElement} input
 */ const removeAttributes = (input)=>{
    for(let i = 0; i < input.attributes.length; i++){
        const attrName = input.attributes[i].name;
        if (![
            'id',
            'type',
            'value',
            'style'
        ].includes(attrName)) {
            input.removeAttribute(attrName);
        }
    }
};
/**
 * @param {InputClass} inputClass
 * @param {SweetAlertOptions['inputAttributes']} inputAttributes
 */ const setAttributes = (inputClass, inputAttributes)=>{
    const popup = getPopup();
    if (!popup) {
        return;
    }
    const input = getInput$1(popup, inputClass);
    if (!input) {
        return;
    }
    removeAttributes(input);
    for(const attr in inputAttributes){
        input.setAttribute(attr, inputAttributes[attr]);
    }
};
/**
 * @param {SweetAlertOptions} params
 */ const setCustomClass = (params)=>{
    if (!params.input) {
        return;
    }
    const inputContainer = getInputContainer(params.input);
    if (inputContainer) {
        applyCustomClass(inputContainer, params, 'input');
    }
};
/**
 * @param {HTMLInputElement | HTMLTextAreaElement} input
 * @param {SweetAlertOptions} params
 */ const setInputPlaceholder = (input, params)=>{
    if (!input.placeholder && params.inputPlaceholder) {
        input.placeholder = params.inputPlaceholder;
    }
};
/**
 * @param {Input} input
 * @param {Input} prependTo
 * @param {SweetAlertOptions} params
 */ const setInputLabel = (input, prependTo, params)=>{
    if (params.inputLabel) {
        const label = document.createElement('label');
        const labelClass = swalClasses['input-label'];
        label.setAttribute('for', input.id);
        label.className = labelClass;
        if (typeof params.customClass === 'object') {
            addClass(label, params.customClass.inputLabel);
        }
        label.innerText = params.inputLabel;
        prependTo.insertAdjacentElement('beforebegin', label);
    }
};
/**
 * @param {SweetAlertInput} inputType
 * @returns {HTMLElement | undefined}
 */ const getInputContainer = (inputType)=>{
    const popup = getPopup();
    if (!popup) {
        return;
    }
    return getDirectChildByClass(popup, swalClasses[/** @type {SwalClass} */ inputType] || swalClasses.input);
};
/**
 * @param {HTMLInputElement | HTMLOutputElement | HTMLTextAreaElement} input
 * @param {SweetAlertOptions['inputValue']} inputValue
 */ const checkAndSetInputValue = (input, inputValue)=>{
    if ([
        'string',
        'number'
    ].includes(typeof inputValue)) {
        input.value = `${inputValue}`;
    } else if (!isPromise(inputValue)) {
        warn(`Unexpected type of inputValue! Expected "string", "number" or "Promise", got "${typeof inputValue}"`);
    }
};
/** @type {Record<SweetAlertInput, (input: Input | HTMLElement, params: SweetAlertOptions) => Input>} */ const renderInputType = {};
/**
 * @param {HTMLInputElement} input
 * @param {SweetAlertOptions} params
 * @returns {HTMLInputElement}
 */ renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = renderInputType.search = renderInputType.date = renderInputType['datetime-local'] = renderInputType.time = renderInputType.week = renderInputType.month = /** @type {(input: Input | HTMLElement, params: SweetAlertOptions) => Input} */ (input, params)=>{
    checkAndSetInputValue(input, params.inputValue);
    setInputLabel(input, input, params);
    setInputPlaceholder(input, params);
    input.type = params.input;
    return input;
};
/**
 * @param {HTMLInputElement} input
 * @param {SweetAlertOptions} params
 * @returns {HTMLInputElement}
 */ renderInputType.file = (input, params)=>{
    setInputLabel(input, input, params);
    setInputPlaceholder(input, params);
    return input;
};
/**
 * @param {HTMLInputElement} range
 * @param {SweetAlertOptions} params
 * @returns {HTMLInputElement}
 */ renderInputType.range = (range, params)=>{
    const rangeInput = range.querySelector('input');
    const rangeOutput = range.querySelector('output');
    checkAndSetInputValue(rangeInput, params.inputValue);
    rangeInput.type = params.input;
    checkAndSetInputValue(rangeOutput, params.inputValue);
    setInputLabel(rangeInput, range, params);
    return range;
};
/**
 * @param {HTMLSelectElement} select
 * @param {SweetAlertOptions} params
 * @returns {HTMLSelectElement}
 */ renderInputType.select = (select, params)=>{
    select.textContent = '';
    if (params.inputPlaceholder) {
        const placeholder = document.createElement('option');
        setInnerHtml(placeholder, params.inputPlaceholder);
        placeholder.value = '';
        placeholder.disabled = true;
        placeholder.selected = true;
        select.appendChild(placeholder);
    }
    setInputLabel(select, select, params);
    return select;
};
/**
 * @param {HTMLInputElement} radio
 * @returns {HTMLInputElement}
 */ renderInputType.radio = (radio)=>{
    radio.textContent = '';
    return radio;
};
/**
 * @param {HTMLLabelElement} checkboxContainer
 * @param {SweetAlertOptions} params
 * @returns {HTMLInputElement}
 */ renderInputType.checkbox = (checkboxContainer, params)=>{
    const checkbox = getInput$1(getPopup(), 'checkbox');
    checkbox.value = '1';
    checkbox.checked = Boolean(params.inputValue);
    const label = checkboxContainer.querySelector('span');
    setInnerHtml(label, params.inputPlaceholder || params.inputLabel);
    return checkbox;
};
/**
 * @param {HTMLTextAreaElement} textarea
 * @param {SweetAlertOptions} params
 * @returns {HTMLTextAreaElement}
 */ renderInputType.textarea = (textarea, params)=>{
    checkAndSetInputValue(textarea, params.inputValue);
    setInputPlaceholder(textarea, params);
    setInputLabel(textarea, textarea, params);
    /**
   * @param {HTMLElement} el
   * @returns {number}
   */ const getMargin = (el)=>parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight);
    // https://github.com/sweetalert2/sweetalert2/issues/2291
    setTimeout(()=>{
        // https://github.com/sweetalert2/sweetalert2/issues/1699
        if ('MutationObserver' in window) {
            const initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);
            const textareaResizeHandler = ()=>{
                // check if texarea is still in document (i.e. popup wasn't closed in the meantime)
                if (!document.body.contains(textarea)) {
                    return;
                }
                const textareaWidth = textarea.offsetWidth + getMargin(textarea);
                if (textareaWidth > initialPopupWidth) {
                    getPopup().style.width = `${textareaWidth}px`;
                } else {
                    applyNumericalStyle(getPopup(), 'width', params.width);
                }
            };
            new MutationObserver(textareaResizeHandler).observe(textarea, {
                attributes: true,
                attributeFilter: [
                    'style'
                ]
            });
        }
    });
    return textarea;
};
/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */ const renderContent = (instance, params)=>{
    const htmlContainer = getHtmlContainer();
    if (!htmlContainer) {
        return;
    }
    showWhenInnerHtmlPresent(htmlContainer);
    applyCustomClass(htmlContainer, params, 'htmlContainer');
    // Content as HTML
    if (params.html) {
        parseHtmlToContainer(params.html, htmlContainer);
        show(htmlContainer, 'block');
    } else if (params.text) {
        htmlContainer.textContent = params.text;
        show(htmlContainer, 'block');
    } else {
        hide(htmlContainer);
    }
    renderInput(instance, params);
};
/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */ const renderFooter = (instance, params)=>{
    const footer = getFooter();
    if (!footer) {
        return;
    }
    showWhenInnerHtmlPresent(footer);
    toggle(footer, params.footer, 'block');
    if (params.footer) {
        parseHtmlToContainer(params.footer, footer);
    }
    // Custom class
    applyCustomClass(footer, params, 'footer');
};
/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */ const renderIcon = (instance, params)=>{
    const innerParams = privateProps.innerParams.get(instance);
    const icon = getIcon();
    if (!icon) {
        return;
    }
    // if the given icon already rendered, apply the styling without re-rendering the icon
    if (innerParams && params.icon === innerParams.icon) {
        // Custom or default content
        setContent(icon, params);
        applyStyles(icon, params);
        return;
    }
    if (!params.icon && !params.iconHtml) {
        hide(icon);
        return;
    }
    if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {
        error(`Unknown icon! Expected "success", "error", "warning", "info" or "question", got "${params.icon}"`);
        hide(icon);
        return;
    }
    show(icon);
    // Custom or default content
    setContent(icon, params);
    applyStyles(icon, params);
    // Animate icon
    addClass(icon, params.showClass && params.showClass.icon);
    // Re-adjust the success icon on system theme change
    const colorSchemeQueryList = window.matchMedia('(prefers-color-scheme: dark)');
    colorSchemeQueryList.addEventListener('change', adjustSuccessIconBackgroundColor);
};
/**
 * @param {HTMLElement} icon
 * @param {SweetAlertOptions} params
 */ const applyStyles = (icon, params)=>{
    for (const [iconType, iconClassName] of Object.entries(iconTypes)){
        if (params.icon !== iconType) {
            removeClass(icon, iconClassName);
        }
    }
    addClass(icon, params.icon && iconTypes[params.icon]);
    // Icon color
    setColor(icon, params);
    // Success icon background color
    adjustSuccessIconBackgroundColor();
    // Custom class
    applyCustomClass(icon, params, 'icon');
};
// Adjust success icon background color to match the popup background color
const adjustSuccessIconBackgroundColor = ()=>{
    const popup = getPopup();
    if (!popup) {
        return;
    }
    const popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue('background-color');
    /** @type {NodeListOf<HTMLElement>} */ const successIconParts = popup.querySelectorAll('[class^=swal2-success-circular-line], .swal2-success-fix');
    for(let i = 0; i < successIconParts.length; i++){
        successIconParts[i].style.backgroundColor = popupBackgroundColor;
    }
};
const successIconHtml = `
  <div class="swal2-success-circular-line-left"></div>
  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>
  <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>
  <div class="swal2-success-circular-line-right"></div>
`;
const errorIconHtml = `
  <span class="swal2-x-mark">
    <span class="swal2-x-mark-line-left"></span>
    <span class="swal2-x-mark-line-right"></span>
  </span>
`;
/**
 * @param {HTMLElement} icon
 * @param {SweetAlertOptions} params
 */ const setContent = (icon, params)=>{
    if (!params.icon && !params.iconHtml) {
        return;
    }
    let oldContent = icon.innerHTML;
    let newContent = '';
    if (params.iconHtml) {
        newContent = iconContent(params.iconHtml);
    } else if (params.icon === 'success') {
        newContent = successIconHtml;
        oldContent = oldContent.replace(/ style=".*?"/g, ''); // undo adjustSuccessIconBackgroundColor()
    } else if (params.icon === 'error') {
        newContent = errorIconHtml;
    } else if (params.icon) {
        const defaultIconHtml = {
            question: '?',
            warning: '!',
            info: 'i'
        };
        newContent = iconContent(defaultIconHtml[params.icon]);
    }
    if (oldContent.trim() !== newContent.trim()) {
        setInnerHtml(icon, newContent);
    }
};
/**
 * @param {HTMLElement} icon
 * @param {SweetAlertOptions} params
 */ const setColor = (icon, params)=>{
    if (!params.iconColor) {
        return;
    }
    icon.style.color = params.iconColor;
    icon.style.borderColor = params.iconColor;
    for (const sel of [
        '.swal2-success-line-tip',
        '.swal2-success-line-long',
        '.swal2-x-mark-line-left',
        '.swal2-x-mark-line-right'
    ]){
        setStyle(icon, sel, 'background-color', params.iconColor);
    }
    setStyle(icon, '.swal2-success-ring', 'border-color', params.iconColor);
};
/**
 * @param {string} content
 * @returns {string}
 */ const iconContent = (content)=>`<div class="${swalClasses['icon-content']}">${content}</div>`;
/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */ const renderImage = (instance, params)=>{
    const image = getImage();
    if (!image) {
        return;
    }
    if (!params.imageUrl) {
        hide(image);
        return;
    }
    show(image, '');
    // Src, alt
    image.setAttribute('src', params.imageUrl);
    image.setAttribute('alt', params.imageAlt || '');
    // Width, height
    applyNumericalStyle(image, 'width', params.imageWidth);
    applyNumericalStyle(image, 'height', params.imageHeight);
    // Class
    image.className = swalClasses.image;
    applyCustomClass(image, params, 'image');
};
let dragging = false;
let mousedownX = 0;
let mousedownY = 0;
let initialX = 0;
let initialY = 0;
/**
 * @param {HTMLElement} popup
 */ const addDraggableListeners = (popup)=>{
    popup.addEventListener('mousedown', down);
    document.body.addEventListener('mousemove', move);
    popup.addEventListener('mouseup', up);
    popup.addEventListener('touchstart', down);
    document.body.addEventListener('touchmove', move);
    popup.addEventListener('touchend', up);
};
/**
 * @param {HTMLElement} popup
 */ const removeDraggableListeners = (popup)=>{
    popup.removeEventListener('mousedown', down);
    document.body.removeEventListener('mousemove', move);
    popup.removeEventListener('mouseup', up);
    popup.removeEventListener('touchstart', down);
    document.body.removeEventListener('touchmove', move);
    popup.removeEventListener('touchend', up);
};
/**
 * @param {MouseEvent | TouchEvent} event
 */ const down = (event)=>{
    const popup = getPopup();
    if (event.target === popup || getIcon().contains(/** @type {HTMLElement} */ event.target)) {
        dragging = true;
        const clientXY = getClientXY(event);
        mousedownX = clientXY.clientX;
        mousedownY = clientXY.clientY;
        initialX = parseInt(popup.style.insetInlineStart) || 0;
        initialY = parseInt(popup.style.insetBlockStart) || 0;
        addClass(popup, 'swal2-dragging');
    }
};
/**
 * @param {MouseEvent | TouchEvent} event
 */ const move = (event)=>{
    const popup = getPopup();
    if (dragging) {
        let { clientX, clientY } = getClientXY(event);
        popup.style.insetInlineStart = `${initialX + (clientX - mousedownX)}px`;
        popup.style.insetBlockStart = `${initialY + (clientY - mousedownY)}px`;
    }
};
const up = ()=>{
    const popup = getPopup();
    dragging = false;
    removeClass(popup, 'swal2-dragging');
};
/**
 * @param {MouseEvent | TouchEvent} event
 * @returns {{ clientX: number, clientY: number }}
 */ const getClientXY = (event)=>{
    let clientX = 0, clientY = 0;
    if (event.type.startsWith('mouse')) {
        clientX = /** @type {MouseEvent} */ event.clientX;
        clientY = /** @type {MouseEvent} */ event.clientY;
    } else if (event.type.startsWith('touch')) {
        clientX = /** @type {TouchEvent} */ event.touches[0].clientX;
        clientY = /** @type {TouchEvent} */ event.touches[0].clientY;
    }
    return {
        clientX,
        clientY
    };
};
/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */ const renderPopup = (instance, params)=>{
    const container = getContainer();
    const popup = getPopup();
    if (!container || !popup) {
        return;
    }
    // Width
    // https://github.com/sweetalert2/sweetalert2/issues/2170
    if (params.toast) {
        applyNumericalStyle(container, 'width', params.width);
        popup.style.width = '100%';
        const loader = getLoader();
        if (loader) {
            popup.insertBefore(loader, getIcon());
        }
    } else {
        applyNumericalStyle(popup, 'width', params.width);
    }
    // Padding
    applyNumericalStyle(popup, 'padding', params.padding);
    // Color
    if (params.color) {
        popup.style.color = params.color;
    }
    // Background
    if (params.background) {
        popup.style.background = params.background;
    }
    hide(getValidationMessage());
    // Classes
    addClasses$1(popup, params);
    if (params.draggable && !params.toast) {
        addClass(popup, swalClasses.draggable);
        addDraggableListeners(popup);
    } else {
        removeClass(popup, swalClasses.draggable);
        removeDraggableListeners(popup);
    }
};
/**
 * @param {HTMLElement} popup
 * @param {SweetAlertOptions} params
 */ const addClasses$1 = (popup, params)=>{
    const showClass = params.showClass || {};
    // Default Class + showClass when updating Swal.update({})
    popup.className = `${swalClasses.popup} ${isVisible$1(popup) ? showClass.popup : ''}`;
    if (params.toast) {
        addClass([
            document.documentElement,
            document.body
        ], swalClasses['toast-shown']);
        addClass(popup, swalClasses.toast);
    } else {
        addClass(popup, swalClasses.modal);
    }
    // Custom class
    applyCustomClass(popup, params, 'popup');
    // TODO: remove in the next major
    if (typeof params.customClass === 'string') {
        addClass(popup, params.customClass);
    }
    // Icon class (#1842)
    if (params.icon) {
        addClass(popup, swalClasses[`icon-${params.icon}`]);
    }
};
/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */ const renderProgressSteps = (instance, params)=>{
    const progressStepsContainer = getProgressSteps();
    if (!progressStepsContainer) {
        return;
    }
    const { progressSteps, currentProgressStep } = params;
    if (!progressSteps || progressSteps.length === 0 || currentProgressStep === undefined) {
        hide(progressStepsContainer);
        return;
    }
    show(progressStepsContainer);
    progressStepsContainer.textContent = '';
    if (currentProgressStep >= progressSteps.length) {
        warn('Invalid currentProgressStep parameter, it should be less than progressSteps.length ' + '(currentProgressStep like JS arrays starts from 0)');
    }
    progressSteps.forEach((step, index)=>{
        const stepEl = createStepElement(step);
        progressStepsContainer.appendChild(stepEl);
        if (index === currentProgressStep) {
            addClass(stepEl, swalClasses['active-progress-step']);
        }
        if (index !== progressSteps.length - 1) {
            const lineEl = createLineElement(params);
            progressStepsContainer.appendChild(lineEl);
        }
    });
};
/**
 * @param {string} step
 * @returns {HTMLLIElement}
 */ const createStepElement = (step)=>{
    const stepEl = document.createElement('li');
    addClass(stepEl, swalClasses['progress-step']);
    setInnerHtml(stepEl, step);
    return stepEl;
};
/**
 * @param {SweetAlertOptions} params
 * @returns {HTMLLIElement}
 */ const createLineElement = (params)=>{
    const lineEl = document.createElement('li');
    addClass(lineEl, swalClasses['progress-step-line']);
    if (params.progressStepsDistance) {
        applyNumericalStyle(lineEl, 'width', params.progressStepsDistance);
    }
    return lineEl;
};
/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */ const renderTitle = (instance, params)=>{
    const title = getTitle();
    if (!title) {
        return;
    }
    showWhenInnerHtmlPresent(title);
    toggle(title, params.title || params.titleText, 'block');
    if (params.title) {
        parseHtmlToContainer(params.title, title);
    }
    if (params.titleText) {
        title.innerText = params.titleText;
    }
    // Custom class
    applyCustomClass(title, params, 'title');
};
/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */ const render = (instance, params)=>{
    renderPopup(instance, params);
    renderContainer(instance, params);
    renderProgressSteps(instance, params);
    renderIcon(instance, params);
    renderImage(instance, params);
    renderTitle(instance, params);
    renderCloseButton(instance, params);
    renderContent(instance, params);
    renderActions(instance, params);
    renderFooter(instance, params);
    const popup = getPopup();
    if (typeof params.didRender === 'function' && popup) {
        params.didRender(popup);
    }
    globalState.eventEmitter.emit('didRender', popup);
};
/*
 * Global function to determine if SweetAlert2 popup is shown
 */ const isVisible = ()=>{
    return isVisible$1(getPopup());
};
/*
 * Global function to click 'Confirm' button
 */ const clickConfirm = ()=>{
    var _dom$getConfirmButton;
    return (_dom$getConfirmButton = getConfirmButton()) === null || _dom$getConfirmButton === void 0 ? void 0 : _dom$getConfirmButton.click();
};
/*
 * Global function to click 'Deny' button
 */ const clickDeny = ()=>{
    var _dom$getDenyButton;
    return (_dom$getDenyButton = getDenyButton()) === null || _dom$getDenyButton === void 0 ? void 0 : _dom$getDenyButton.click();
};
/*
 * Global function to click 'Cancel' button
 */ const clickCancel = ()=>{
    var _dom$getCancelButton;
    return (_dom$getCancelButton = getCancelButton()) === null || _dom$getCancelButton === void 0 ? void 0 : _dom$getCancelButton.click();
};
/** @typedef {'cancel' | 'backdrop' | 'close' | 'esc' | 'timer'} DismissReason */ /** @type {Record<DismissReason, DismissReason>} */ const DismissReason = Object.freeze({
    cancel: 'cancel',
    backdrop: 'backdrop',
    close: 'close',
    esc: 'esc',
    timer: 'timer'
});
/**
 * @param {GlobalState} globalState
 */ const removeKeydownHandler = (globalState)=>{
    if (globalState.keydownTarget && globalState.keydownHandlerAdded) {
        globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {
            capture: globalState.keydownListenerCapture
        });
        globalState.keydownHandlerAdded = false;
    }
};
/**
 * @param {GlobalState} globalState
 * @param {SweetAlertOptions} innerParams
 * @param {*} dismissWith
 */ const addKeydownHandler = (globalState, innerParams, dismissWith)=>{
    removeKeydownHandler(globalState);
    if (!innerParams.toast) {
        globalState.keydownHandler = (e)=>keydownHandler(innerParams, e, dismissWith);
        globalState.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();
        globalState.keydownListenerCapture = innerParams.keydownListenerCapture;
        globalState.keydownTarget.addEventListener('keydown', globalState.keydownHandler, {
            capture: globalState.keydownListenerCapture
        });
        globalState.keydownHandlerAdded = true;
    }
};
/**
 * @param {number} index
 * @param {number} increment
 */ const setFocus = (index, increment)=>{
    var _dom$getPopup;
    const focusableElements = getFocusableElements();
    // search for visible elements and select the next possible match
    if (focusableElements.length) {
        index = index + increment;
        // shift + tab when .swal2-popup is focused
        if (index === -2) {
            index = focusableElements.length - 1;
        }
        // rollover to first item
        if (index === focusableElements.length) {
            index = 0;
        // go to last item
        } else if (index === -1) {
            index = focusableElements.length - 1;
        }
        focusableElements[index].focus();
        return;
    }
    // no visible focusable elements, focus the popup
    (_dom$getPopup = getPopup()) === null || _dom$getPopup === void 0 || _dom$getPopup.focus();
};
const arrowKeysNextButton = [
    'ArrowRight',
    'ArrowDown'
];
const arrowKeysPreviousButton = [
    'ArrowLeft',
    'ArrowUp'
];
/**
 * @param {SweetAlertOptions} innerParams
 * @param {KeyboardEvent} event
 * @param {Function} dismissWith
 */ const keydownHandler = (innerParams, event, dismissWith)=>{
    if (!innerParams) {
        return; // This instance has already been destroyed
    }
    // Ignore keydown during IME composition
    // https://developer.mozilla.org/en-US/docs/Web/API/Document/keydown_event#ignoring_keydown_during_ime_composition
    // https://github.com/sweetalert2/sweetalert2/issues/720
    // https://github.com/sweetalert2/sweetalert2/issues/2406
    if (event.isComposing || event.keyCode === 229) {
        return;
    }
    if (innerParams.stopKeydownPropagation) {
        event.stopPropagation();
    }
    // ENTER
    if (event.key === 'Enter') {
        handleEnter(event, innerParams);
    } else if (event.key === 'Tab') {
        handleTab(event);
    } else if ([
        ...arrowKeysNextButton,
        ...arrowKeysPreviousButton
    ].includes(event.key)) {
        handleArrows(event.key);
    } else if (event.key === 'Escape') {
        handleEsc(event, innerParams, dismissWith);
    }
};
/**
 * @param {KeyboardEvent} event
 * @param {SweetAlertOptions} innerParams
 */ const handleEnter = (event, innerParams)=>{
    // https://github.com/sweetalert2/sweetalert2/issues/2386
    if (!callIfFunction(innerParams.allowEnterKey)) {
        return;
    }
    const input = getInput$1(getPopup(), innerParams.input);
    if (event.target && input && event.target instanceof HTMLElement && event.target.outerHTML === input.outerHTML) {
        if ([
            'textarea',
            'file'
        ].includes(innerParams.input)) {
            return; // do not submit
        }
        clickConfirm();
        event.preventDefault();
    }
};
/**
 * @param {KeyboardEvent} event
 */ const handleTab = (event)=>{
    const targetElement = event.target;
    const focusableElements = getFocusableElements();
    let btnIndex = -1;
    for(let i = 0; i < focusableElements.length; i++){
        if (targetElement === focusableElements[i]) {
            btnIndex = i;
            break;
        }
    }
    // Cycle to the next button
    if (!event.shiftKey) {
        setFocus(btnIndex, 1);
    } else {
        setFocus(btnIndex, -1);
    }
    event.stopPropagation();
    event.preventDefault();
};
/**
 * @param {string} key
 */ const handleArrows = (key)=>{
    const actions = getActions();
    const confirmButton = getConfirmButton();
    const denyButton = getDenyButton();
    const cancelButton = getCancelButton();
    if (!actions || !confirmButton || !denyButton || !cancelButton) {
        return;
    }
    /** @type HTMLElement[] */ const buttons = [
        confirmButton,
        denyButton,
        cancelButton
    ];
    if (document.activeElement instanceof HTMLElement && !buttons.includes(document.activeElement)) {
        return;
    }
    const sibling = arrowKeysNextButton.includes(key) ? 'nextElementSibling' : 'previousElementSibling';
    let buttonToFocus = document.activeElement;
    if (!buttonToFocus) {
        return;
    }
    for(let i = 0; i < actions.children.length; i++){
        buttonToFocus = buttonToFocus[sibling];
        if (!buttonToFocus) {
            return;
        }
        if (buttonToFocus instanceof HTMLButtonElement && isVisible$1(buttonToFocus)) {
            break;
        }
    }
    if (buttonToFocus instanceof HTMLButtonElement) {
        buttonToFocus.focus();
    }
};
/**
 * @param {KeyboardEvent} event
 * @param {SweetAlertOptions} innerParams
 * @param {Function} dismissWith
 */ const handleEsc = (event, innerParams, dismissWith)=>{
    if (callIfFunction(innerParams.allowEscapeKey)) {
        event.preventDefault();
        dismissWith(DismissReason.esc);
    }
};
/**
 * This module contains `WeakMap`s for each effectively-"private  property" that a `Swal` has.
 * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
 * This is the approach that Babel will probably take to implement private methods/fields
 *   https://github.com/tc39/proposal-private-methods
 *   https://github.com/babel/babel/pull/7555
 * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
 *   then we can use that language feature.
 */ var privateMethods = {
    swalPromiseResolve: new WeakMap(),
    swalPromiseReject: new WeakMap()
};
// From https://developer.paciellogroup.com/blog/2018/06/the-current-state-of-modal-dialog-accessibility/
// Adding aria-hidden="true" to elements outside of the active modal dialog ensures that
// elements not within the active modal dialog will not be surfaced if a user opens a screen
// reader’s list of elements (headings, form controls, landmarks, etc.) in the document.
const setAriaHidden = ()=>{
    const container = getContainer();
    const bodyChildren = Array.from(document.body.children);
    bodyChildren.forEach((el)=>{
        if (el.contains(container)) {
            return;
        }
        if (el.hasAttribute('aria-hidden')) {
            el.setAttribute('data-previous-aria-hidden', el.getAttribute('aria-hidden') || '');
        }
        el.setAttribute('aria-hidden', 'true');
    });
};
const unsetAriaHidden = ()=>{
    const bodyChildren = Array.from(document.body.children);
    bodyChildren.forEach((el)=>{
        if (el.hasAttribute('data-previous-aria-hidden')) {
            el.setAttribute('aria-hidden', el.getAttribute('data-previous-aria-hidden') || '');
            el.removeAttribute('data-previous-aria-hidden');
        } else {
            el.removeAttribute('aria-hidden');
        }
    });
};
// @ts-ignore
const isSafariOrIOS = typeof window !== 'undefined' && !!window.GestureEvent; // true for Safari desktop + all iOS browsers https://stackoverflow.com/a/70585394
/**
 * Fix iOS scrolling
 * http://stackoverflow.com/q/39626302
 */ const iOSfix = ()=>{
    if (isSafariOrIOS && !hasClass(document.body, swalClasses.iosfix)) {
        const offset = document.body.scrollTop;
        document.body.style.top = `${offset * -1}px`;
        addClass(document.body, swalClasses.iosfix);
        lockBodyScroll();
    }
};
/**
 * https://github.com/sweetalert2/sweetalert2/issues/1246
 */ const lockBodyScroll = ()=>{
    const container = getContainer();
    if (!container) {
        return;
    }
    /** @type {boolean} */ let preventTouchMove;
    /**
   * @param {TouchEvent} event
   */ container.ontouchstart = (event)=>{
        preventTouchMove = shouldPreventTouchMove(event);
    };
    /**
   * @param {TouchEvent} event
   */ container.ontouchmove = (event)=>{
        if (preventTouchMove) {
            event.preventDefault();
            event.stopPropagation();
        }
    };
};
/**
 * @param {TouchEvent} event
 * @returns {boolean}
 */ const shouldPreventTouchMove = (event)=>{
    const target = event.target;
    const container = getContainer();
    const htmlContainer = getHtmlContainer();
    if (!container || !htmlContainer) {
        return false;
    }
    if (isStylus(event) || isZoom(event)) {
        return false;
    }
    if (target === container) {
        return true;
    }
    if (!isScrollable(container) && target instanceof HTMLElement && target.tagName !== 'INPUT' && // #1603
    target.tagName !== 'TEXTAREA' && // #2266
    !(isScrollable(htmlContainer) && // #1944
    htmlContainer.contains(target))) {
        return true;
    }
    return false;
};
/**
 * https://github.com/sweetalert2/sweetalert2/issues/1786
 *
 * @param {*} event
 * @returns {boolean}
 */ const isStylus = (event)=>{
    return event.touches && event.touches.length && event.touches[0].touchType === 'stylus';
};
/**
 * https://github.com/sweetalert2/sweetalert2/issues/1891
 *
 * @param {TouchEvent} event
 * @returns {boolean}
 */ const isZoom = (event)=>{
    return event.touches && event.touches.length > 1;
};
const undoIOSfix = ()=>{
    if (hasClass(document.body, swalClasses.iosfix)) {
        const offset = parseInt(document.body.style.top, 10);
        removeClass(document.body, swalClasses.iosfix);
        document.body.style.top = '';
        document.body.scrollTop = offset * -1;
    }
};
/**
 * Measure scrollbar width for padding body during modal show/hide
 * https://github.com/twbs/bootstrap/blob/master/js/src/modal.js
 *
 * @returns {number}
 */ const measureScrollbar = ()=>{
    const scrollDiv = document.createElement('div');
    scrollDiv.className = swalClasses['scrollbar-measure'];
    document.body.appendChild(scrollDiv);
    const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
    return scrollbarWidth;
};
/**
 * Remember state in cases where opening and handling a modal will fiddle with it.
 * @type {number | null}
 */ let previousBodyPadding = null;
/**
 * @param {string} initialBodyOverflow
 */ const replaceScrollbarWithPadding = (initialBodyOverflow)=>{
    // for queues, do not do this more than once
    if (previousBodyPadding !== null) {
        return;
    }
    // if the body has overflow
    if (document.body.scrollHeight > window.innerHeight || initialBodyOverflow === 'scroll' // https://github.com/sweetalert2/sweetalert2/issues/2663
    ) {
        // add padding so the content doesn't shift after removal of scrollbar
        previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue('padding-right'));
        document.body.style.paddingRight = `${previousBodyPadding + measureScrollbar()}px`;
    }
};
const undoReplaceScrollbarWithPadding = ()=>{
    if (previousBodyPadding !== null) {
        document.body.style.paddingRight = `${previousBodyPadding}px`;
        previousBodyPadding = null;
    }
};
/**
 * @param {SweetAlert} instance
 * @param {HTMLElement} container
 * @param {boolean} returnFocus
 * @param {Function} didClose
 */ function removePopupAndResetState(instance, container, returnFocus, didClose) {
    if (isToast()) {
        triggerDidCloseAndDispose(instance, didClose);
    } else {
        restoreActiveElement(returnFocus).then(()=>triggerDidCloseAndDispose(instance, didClose));
        removeKeydownHandler(globalState);
    }
    // workaround for https://github.com/sweetalert2/sweetalert2/issues/2088
    // for some reason removing the container in Safari will scroll the document to bottom
    if (isSafariOrIOS) {
        container.setAttribute('style', 'display:none !important');
        container.removeAttribute('class');
        container.innerHTML = '';
    } else {
        container.remove();
    }
    if (isModal()) {
        undoReplaceScrollbarWithPadding();
        undoIOSfix();
        unsetAriaHidden();
    }
    removeBodyClasses();
}
/**
 * Remove SweetAlert2 classes from body
 */ function removeBodyClasses() {
    removeClass([
        document.documentElement,
        document.body
    ], [
        swalClasses.shown,
        swalClasses['height-auto'],
        swalClasses['no-backdrop'],
        swalClasses['toast-shown']
    ]);
}
/**
 * Instance method to close sweetAlert
 *
 * @param {any} resolveValue
 */ function close(resolveValue) {
    resolveValue = prepareResolveValue(resolveValue);
    const swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);
    const didClose = triggerClosePopup(this);
    if (this.isAwaitingPromise) {
        // A swal awaiting for a promise (after a click on Confirm or Deny) cannot be dismissed anymore #2335
        if (!resolveValue.isDismissed) {
            handleAwaitingPromise(this);
            swalPromiseResolve(resolveValue);
        }
    } else if (didClose) {
        // Resolve Swal promise
        swalPromiseResolve(resolveValue);
    }
}
const triggerClosePopup = (instance)=>{
    const popup = getPopup();
    if (!popup) {
        return false;
    }
    const innerParams = privateProps.innerParams.get(instance);
    if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {
        return false;
    }
    removeClass(popup, innerParams.showClass.popup);
    addClass(popup, innerParams.hideClass.popup);
    const backdrop = getContainer();
    removeClass(backdrop, innerParams.showClass.backdrop);
    addClass(backdrop, innerParams.hideClass.backdrop);
    handlePopupAnimation(instance, popup, innerParams);
    return true;
};
/**
 * @param {any} error
 */ function rejectPromise(error) {
    const rejectPromise = privateMethods.swalPromiseReject.get(this);
    handleAwaitingPromise(this);
    if (rejectPromise) {
        // Reject Swal promise
        rejectPromise(error);
    }
}
/**
 * @param {SweetAlert} instance
 */ const handleAwaitingPromise = (instance)=>{
    if (instance.isAwaitingPromise) {
        delete instance.isAwaitingPromise;
        // The instance might have been previously partly destroyed, we must resume the destroy process in this case #2335
        if (!privateProps.innerParams.get(instance)) {
            instance._destroy();
        }
    }
};
/**
 * @param {any} resolveValue
 * @returns {SweetAlertResult}
 */ const prepareResolveValue = (resolveValue)=>{
    // When user calls Swal.close()
    if (typeof resolveValue === 'undefined') {
        return {
            isConfirmed: false,
            isDenied: false,
            isDismissed: true
        };
    }
    return Object.assign({
        isConfirmed: false,
        isDenied: false,
        isDismissed: false
    }, resolveValue);
};
/**
 * @param {SweetAlert} instance
 * @param {HTMLElement} popup
 * @param {SweetAlertOptions} innerParams
 */ const handlePopupAnimation = (instance, popup, innerParams)=>{
    var _globalState$eventEmi;
    const container = getContainer();
    // If animation is supported, animate
    const animationIsSupported = hasCssAnimation(popup);
    if (typeof innerParams.willClose === 'function') {
        innerParams.willClose(popup);
    }
    (_globalState$eventEmi = globalState.eventEmitter) === null || _globalState$eventEmi === void 0 || _globalState$eventEmi.emit('willClose', popup);
    if (animationIsSupported) {
        animatePopup(instance, popup, container, innerParams.returnFocus, innerParams.didClose);
    } else {
        // Otherwise, remove immediately
        removePopupAndResetState(instance, container, innerParams.returnFocus, innerParams.didClose);
    }
};
/**
 * @param {SweetAlert} instance
 * @param {HTMLElement} popup
 * @param {HTMLElement} container
 * @param {boolean} returnFocus
 * @param {Function} didClose
 */ const animatePopup = (instance, popup, container, returnFocus, didClose)=>{
    globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);
    /**
   * @param {AnimationEvent | TransitionEvent} e
   */ const swalCloseAnimationFinished = function(e) {
        if (e.target === popup) {
            var _globalState$swalClos;
            (_globalState$swalClos = globalState.swalCloseEventFinishedCallback) === null || _globalState$swalClos === void 0 || _globalState$swalClos.call(globalState);
            delete globalState.swalCloseEventFinishedCallback;
            popup.removeEventListener('animationend', swalCloseAnimationFinished);
            popup.removeEventListener('transitionend', swalCloseAnimationFinished);
        }
    };
    popup.addEventListener('animationend', swalCloseAnimationFinished);
    popup.addEventListener('transitionend', swalCloseAnimationFinished);
};
/**
 * @param {SweetAlert} instance
 * @param {Function} didClose
 */ const triggerDidCloseAndDispose = (instance, didClose)=>{
    setTimeout(()=>{
        var _globalState$eventEmi2;
        if (typeof didClose === 'function') {
            didClose.bind(instance.params)();
        }
        (_globalState$eventEmi2 = globalState.eventEmitter) === null || _globalState$eventEmi2 === void 0 || _globalState$eventEmi2.emit('didClose');
        // instance might have been destroyed already
        if (instance._destroy) {
            instance._destroy();
        }
    });
};
/**
 * Shows loader (spinner), this is useful with AJAX requests.
 * By default the loader be shown instead of the "Confirm" button.
 *
 * @param {HTMLButtonElement | null} [buttonToReplace]
 */ const showLoading = (buttonToReplace)=>{
    let popup = getPopup();
    if (!popup) {
        new Swal();
    }
    popup = getPopup();
    if (!popup) {
        return;
    }
    const loader = getLoader();
    if (isToast()) {
        hide(getIcon());
    } else {
        replaceButton(popup, buttonToReplace);
    }
    show(loader);
    popup.setAttribute('data-loading', 'true');
    popup.setAttribute('aria-busy', 'true');
    popup.focus();
};
/**
 * @param {HTMLElement} popup
 * @param {HTMLButtonElement | null} [buttonToReplace]
 */ const replaceButton = (popup, buttonToReplace)=>{
    const actions = getActions();
    const loader = getLoader();
    if (!actions || !loader) {
        return;
    }
    if (!buttonToReplace && isVisible$1(getConfirmButton())) {
        buttonToReplace = getConfirmButton();
    }
    show(actions);
    if (buttonToReplace) {
        hide(buttonToReplace);
        loader.setAttribute('data-button-to-replace', buttonToReplace.className);
        actions.insertBefore(loader, buttonToReplace);
    }
    addClass([
        popup,
        actions
    ], swalClasses.loading);
};
/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */ const handleInputOptionsAndValue = (instance, params)=>{
    if (params.input === 'select' || params.input === 'radio') {
        handleInputOptions(instance, params);
    } else if ([
        'text',
        'email',
        'number',
        'tel',
        'textarea'
    ].some((i)=>i === params.input) && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {
        showLoading(getConfirmButton());
        handleInputValue(instance, params);
    }
};
/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} innerParams
 * @returns {SweetAlertInputValue}
 */ const getInputValue = (instance, innerParams)=>{
    const input = instance.getInput();
    if (!input) {
        return null;
    }
    switch(innerParams.input){
        case 'checkbox':
            return getCheckboxValue(input);
        case 'radio':
            return getRadioValue(input);
        case 'file':
            return getFileValue(input);
        default:
            return innerParams.inputAutoTrim ? input.value.trim() : input.value;
    }
};
/**
 * @param {HTMLInputElement} input
 * @returns {number}
 */ const getCheckboxValue = (input)=>input.checked ? 1 : 0;
/**
 * @param {HTMLInputElement} input
 * @returns {string | null}
 */ const getRadioValue = (input)=>input.checked ? input.value : null;
/**
 * @param {HTMLInputElement} input
 * @returns {FileList | File | null}
 */ const getFileValue = (input)=>input.files && input.files.length ? input.getAttribute('multiple') !== null ? input.files : input.files[0] : null;
/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */ const handleInputOptions = (instance, params)=>{
    const popup = getPopup();
    if (!popup) {
        return;
    }
    /**
   * @param {Record<string, any>} inputOptions
   */ const processInputOptions = (inputOptions)=>{
        if (params.input === 'select') {
            populateSelectOptions(popup, formatInputOptions(inputOptions), params);
        } else if (params.input === 'radio') {
            populateRadioOptions(popup, formatInputOptions(inputOptions), params);
        }
    };
    if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {
        showLoading(getConfirmButton());
        asPromise(params.inputOptions).then((inputOptions)=>{
            instance.hideLoading();
            processInputOptions(inputOptions);
        });
    } else if (typeof params.inputOptions === 'object') {
        processInputOptions(params.inputOptions);
    } else {
        error(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof params.inputOptions}`);
    }
};
/**
 * @param {SweetAlert} instance
 * @param {SweetAlertOptions} params
 */ const handleInputValue = (instance, params)=>{
    const input = instance.getInput();
    if (!input) {
        return;
    }
    hide(input);
    asPromise(params.inputValue).then((inputValue)=>{
        input.value = params.input === 'number' ? `${parseFloat(inputValue) || 0}` : `${inputValue}`;
        show(input);
        input.focus();
        instance.hideLoading();
    }).catch((err)=>{
        error(`Error in inputValue promise: ${err}`);
        input.value = '';
        show(input);
        input.focus();
        instance.hideLoading();
    });
};
/**
 * @param {HTMLElement} popup
 * @param {InputOptionFlattened[]} inputOptions
 * @param {SweetAlertOptions} params
 */ function populateSelectOptions(popup, inputOptions, params) {
    const select = getDirectChildByClass(popup, swalClasses.select);
    if (!select) {
        return;
    }
    /**
   * @param {HTMLElement} parent
   * @param {string} optionLabel
   * @param {string} optionValue
   */ const renderOption = (parent, optionLabel, optionValue)=>{
        const option = document.createElement('option');
        option.value = optionValue;
        setInnerHtml(option, optionLabel);
        option.selected = isSelected(optionValue, params.inputValue);
        parent.appendChild(option);
    };
    inputOptions.forEach((inputOption)=>{
        const optionValue = inputOption[0];
        const optionLabel = inputOption[1];
        // <optgroup> spec:
        // https://www.w3.org/TR/html401/interact/forms.html#h-17.6
        // "...all OPTGROUP elements must be specified directly within a SELECT element (i.e., groups may not be nested)..."
        // check whether this is a <optgroup>
        if (Array.isArray(optionLabel)) {
            // if it is an array, then it is an <optgroup>
            const optgroup = document.createElement('optgroup');
            optgroup.label = optionValue;
            optgroup.disabled = false; // not configurable for now
            select.appendChild(optgroup);
            optionLabel.forEach((o)=>renderOption(optgroup, o[1], o[0]));
        } else {
            // case of <option>
            renderOption(select, optionLabel, optionValue);
        }
    });
    select.focus();
}
/**
 * @param {HTMLElement} popup
 * @param {InputOptionFlattened[]} inputOptions
 * @param {SweetAlertOptions} params
 */ function populateRadioOptions(popup, inputOptions, params) {
    const radio = getDirectChildByClass(popup, swalClasses.radio);
    if (!radio) {
        return;
    }
    inputOptions.forEach((inputOption)=>{
        const radioValue = inputOption[0];
        const radioLabel = inputOption[1];
        const radioInput = document.createElement('input');
        const radioLabelElement = document.createElement('label');
        radioInput.type = 'radio';
        radioInput.name = swalClasses.radio;
        radioInput.value = radioValue;
        if (isSelected(radioValue, params.inputValue)) {
            radioInput.checked = true;
        }
        const label = document.createElement('span');
        setInnerHtml(label, radioLabel);
        label.className = swalClasses.label;
        radioLabelElement.appendChild(radioInput);
        radioLabelElement.appendChild(label);
        radio.appendChild(radioLabelElement);
    });
    const radios = radio.querySelectorAll('input');
    if (radios.length) {
        radios[0].focus();
    }
}
/**
 * Converts `inputOptions` into an array of `[value, label]`s
 *
 * @param {Record<string, any>} inputOptions
 * @typedef {string[]} InputOptionFlattened
 * @returns {InputOptionFlattened[]}
 */ const formatInputOptions = (inputOptions)=>{
    /** @type {InputOptionFlattened[]} */ const result = [];
    if (inputOptions instanceof Map) {
        inputOptions.forEach((value, key)=>{
            let valueFormatted = value;
            if (typeof valueFormatted === 'object') {
                // case of <optgroup>
                valueFormatted = formatInputOptions(valueFormatted);
            }
            result.push([
                key,
                valueFormatted
            ]);
        });
    } else {
        Object.keys(inputOptions).forEach((key)=>{
            let valueFormatted = inputOptions[key];
            if (typeof valueFormatted === 'object') {
                // case of <optgroup>
                valueFormatted = formatInputOptions(valueFormatted);
            }
            result.push([
                key,
                valueFormatted
            ]);
        });
    }
    return result;
};
/**
 * @param {string} optionValue
 * @param {SweetAlertInputValue} inputValue
 * @returns {boolean}
 */ const isSelected = (optionValue, inputValue)=>{
    return !!inputValue && inputValue.toString() === optionValue.toString();
};
/**
 * @param {SweetAlert} instance
 */ const handleConfirmButtonClick = (instance)=>{
    const innerParams = privateProps.innerParams.get(instance);
    instance.disableButtons();
    if (innerParams.input) {
        handleConfirmOrDenyWithInput(instance, 'confirm');
    } else {
        confirm(instance, true);
    }
};
/**
 * @param {SweetAlert} instance
 */ const handleDenyButtonClick = (instance)=>{
    const innerParams = privateProps.innerParams.get(instance);
    instance.disableButtons();
    if (innerParams.returnInputValueOnDeny) {
        handleConfirmOrDenyWithInput(instance, 'deny');
    } else {
        deny(instance, false);
    }
};
/**
 * @param {SweetAlert} instance
 * @param {Function} dismissWith
 */ const handleCancelButtonClick = (instance, dismissWith)=>{
    instance.disableButtons();
    dismissWith(DismissReason.cancel);
};
/**
 * @param {SweetAlert} instance
 * @param {'confirm' | 'deny'} type
 */ const handleConfirmOrDenyWithInput = (instance, type)=>{
    const innerParams = privateProps.innerParams.get(instance);
    if (!innerParams.input) {
        error(`The "input" parameter is needed to be set when using returnInputValueOn${capitalizeFirstLetter(type)}`);
        return;
    }
    const input = instance.getInput();
    const inputValue = getInputValue(instance, innerParams);
    if (innerParams.inputValidator) {
        handleInputValidator(instance, inputValue, type);
    } else if (input && !input.checkValidity()) {
        instance.enableButtons();
        instance.showValidationMessage(innerParams.validationMessage || input.validationMessage);
    } else if (type === 'deny') {
        deny(instance, inputValue);
    } else {
        confirm(instance, inputValue);
    }
};
/**
 * @param {SweetAlert} instance
 * @param {SweetAlertInputValue} inputValue
 * @param {'confirm' | 'deny'} type
 */ const handleInputValidator = (instance, inputValue, type)=>{
    const innerParams = privateProps.innerParams.get(instance);
    instance.disableInput();
    const validationPromise = Promise.resolve().then(()=>asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage)));
    validationPromise.then((validationMessage)=>{
        instance.enableButtons();
        instance.enableInput();
        if (validationMessage) {
            instance.showValidationMessage(validationMessage);
        } else if (type === 'deny') {
            deny(instance, inputValue);
        } else {
            confirm(instance, inputValue);
        }
    });
};
/**
 * @param {SweetAlert} instance
 * @param {any} value
 */ const deny = (instance, value)=>{
    const innerParams = privateProps.innerParams.get(instance || undefined);
    if (innerParams.showLoaderOnDeny) {
        showLoading(getDenyButton());
    }
    if (innerParams.preDeny) {
        instance.isAwaitingPromise = true; // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preDeny's promise is received
        const preDenyPromise = Promise.resolve().then(()=>asPromise(innerParams.preDeny(value, innerParams.validationMessage)));
        preDenyPromise.then((preDenyValue)=>{
            if (preDenyValue === false) {
                instance.hideLoading();
                handleAwaitingPromise(instance);
            } else {
                instance.close({
                    isDenied: true,
                    value: typeof preDenyValue === 'undefined' ? value : preDenyValue
                });
            }
        }).catch((error)=>rejectWith(instance || undefined, error));
    } else {
        instance.close({
            isDenied: true,
            value
        });
    }
};
/**
 * @param {SweetAlert} instance
 * @param {any} value
 */ const succeedWith = (instance, value)=>{
    instance.close({
        isConfirmed: true,
        value
    });
};
/**
 *
 * @param {SweetAlert} instance
 * @param {string} error
 */ const rejectWith = (instance, error)=>{
    instance.rejectPromise(error);
};
/**
 *
 * @param {SweetAlert} instance
 * @param {any} value
 */ const confirm = (instance, value)=>{
    const innerParams = privateProps.innerParams.get(instance || undefined);
    if (innerParams.showLoaderOnConfirm) {
        showLoading();
    }
    if (innerParams.preConfirm) {
        instance.resetValidationMessage();
        instance.isAwaitingPromise = true; // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preConfirm's promise is received
        const preConfirmPromise = Promise.resolve().then(()=>asPromise(innerParams.preConfirm(value, innerParams.validationMessage)));
        preConfirmPromise.then((preConfirmValue)=>{
            if (isVisible$1(getValidationMessage()) || preConfirmValue === false) {
                instance.hideLoading();
                handleAwaitingPromise(instance);
            } else {
                succeedWith(instance, typeof preConfirmValue === 'undefined' ? value : preConfirmValue);
            }
        }).catch((error)=>rejectWith(instance || undefined, error));
    } else {
        succeedWith(instance, value);
    }
};
/**
 * Hides loader and shows back the button which was hidden by .showLoading()
 */ function hideLoading() {
    // do nothing if popup is closed
    const innerParams = privateProps.innerParams.get(this);
    if (!innerParams) {
        return;
    }
    const domCache = privateProps.domCache.get(this);
    hide(domCache.loader);
    if (isToast()) {
        if (innerParams.icon) {
            show(getIcon());
        }
    } else {
        showRelatedButton(domCache);
    }
    removeClass([
        domCache.popup,
        domCache.actions
    ], swalClasses.loading);
    domCache.popup.removeAttribute('aria-busy');
    domCache.popup.removeAttribute('data-loading');
    domCache.confirmButton.disabled = false;
    domCache.denyButton.disabled = false;
    domCache.cancelButton.disabled = false;
}
const showRelatedButton = (domCache)=>{
    const buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute('data-button-to-replace'));
    if (buttonToReplace.length) {
        show(buttonToReplace[0], 'inline-block');
    } else if (allButtonsAreHidden()) {
        hide(domCache.actions);
    }
};
/**
 * Gets the input DOM node, this method works with input parameter.
 *
 * @returns {HTMLInputElement | null}
 */ function getInput() {
    const innerParams = privateProps.innerParams.get(this);
    const domCache = privateProps.domCache.get(this);
    if (!domCache) {
        return null;
    }
    return getInput$1(domCache.popup, innerParams.input);
}
/**
 * @param {SweetAlert} instance
 * @param {string[]} buttons
 * @param {boolean} disabled
 */ function setButtonsDisabled(instance, buttons, disabled) {
    const domCache = privateProps.domCache.get(instance);
    buttons.forEach((button)=>{
        domCache[button].disabled = disabled;
    });
}
/**
 * @param {HTMLInputElement | null} input
 * @param {boolean} disabled
 */ function setInputDisabled(input, disabled) {
    const popup = getPopup();
    if (!popup || !input) {
        return;
    }
    if (input.type === 'radio') {
        /** @type {NodeListOf<HTMLInputElement>} */ const radios = popup.querySelectorAll(`[name="${swalClasses.radio}"]`);
        for(let i = 0; i < radios.length; i++){
            radios[i].disabled = disabled;
        }
    } else {
        input.disabled = disabled;
    }
}
/**
 * Enable all the buttons
 * @this {SweetAlert}
 */ function enableButtons() {
    setButtonsDisabled(this, [
        'confirmButton',
        'denyButton',
        'cancelButton'
    ], false);
}
/**
 * Disable all the buttons
 * @this {SweetAlert}
 */ function disableButtons() {
    setButtonsDisabled(this, [
        'confirmButton',
        'denyButton',
        'cancelButton'
    ], true);
}
/**
 * Enable the input field
 * @this {SweetAlert}
 */ function enableInput() {
    setInputDisabled(this.getInput(), false);
}
/**
 * Disable the input field
 * @this {SweetAlert}
 */ function disableInput() {
    setInputDisabled(this.getInput(), true);
}
/**
 * Show block with validation message
 *
 * @param {string} error
 * @this {SweetAlert}
 */ function showValidationMessage(error) {
    const domCache = privateProps.domCache.get(this);
    const params = privateProps.innerParams.get(this);
    setInnerHtml(domCache.validationMessage, error);
    domCache.validationMessage.className = swalClasses['validation-message'];
    if (params.customClass && params.customClass.validationMessage) {
        addClass(domCache.validationMessage, params.customClass.validationMessage);
    }
    show(domCache.validationMessage);
    const input = this.getInput();
    if (input) {
        input.setAttribute('aria-invalid', 'true');
        input.setAttribute('aria-describedby', swalClasses['validation-message']);
        focusInput(input);
        addClass(input, swalClasses.inputerror);
    }
}
/**
 * Hide block with validation message
 *
 * @this {SweetAlert}
 */ function resetValidationMessage() {
    const domCache = privateProps.domCache.get(this);
    if (domCache.validationMessage) {
        hide(domCache.validationMessage);
    }
    const input = this.getInput();
    if (input) {
        input.removeAttribute('aria-invalid');
        input.removeAttribute('aria-describedby');
        removeClass(input, swalClasses.inputerror);
    }
}
const defaultParams = {
    title: '',
    titleText: '',
    text: '',
    html: '',
    footer: '',
    icon: undefined,
    iconColor: undefined,
    iconHtml: undefined,
    template: undefined,
    toast: false,
    draggable: false,
    animation: true,
    theme: 'light',
    showClass: {
        popup: 'swal2-show',
        backdrop: 'swal2-backdrop-show',
        icon: 'swal2-icon-show'
    },
    hideClass: {
        popup: 'swal2-hide',
        backdrop: 'swal2-backdrop-hide',
        icon: 'swal2-icon-hide'
    },
    customClass: {},
    target: 'body',
    color: undefined,
    backdrop: true,
    heightAuto: true,
    allowOutsideClick: true,
    allowEscapeKey: true,
    allowEnterKey: true,
    stopKeydownPropagation: true,
    keydownListenerCapture: false,
    showConfirmButton: true,
    showDenyButton: false,
    showCancelButton: false,
    preConfirm: undefined,
    preDeny: undefined,
    confirmButtonText: 'OK',
    confirmButtonAriaLabel: '',
    confirmButtonColor: undefined,
    denyButtonText: 'No',
    denyButtonAriaLabel: '',
    denyButtonColor: undefined,
    cancelButtonText: 'Cancel',
    cancelButtonAriaLabel: '',
    cancelButtonColor: undefined,
    buttonsStyling: true,
    reverseButtons: false,
    focusConfirm: true,
    focusDeny: false,
    focusCancel: false,
    returnFocus: true,
    showCloseButton: false,
    closeButtonHtml: '&times;',
    closeButtonAriaLabel: 'Close this dialog',
    loaderHtml: '',
    showLoaderOnConfirm: false,
    showLoaderOnDeny: false,
    imageUrl: undefined,
    imageWidth: undefined,
    imageHeight: undefined,
    imageAlt: '',
    timer: undefined,
    timerProgressBar: false,
    width: undefined,
    padding: undefined,
    background: undefined,
    input: undefined,
    inputPlaceholder: '',
    inputLabel: '',
    inputValue: '',
    inputOptions: {},
    inputAutoFocus: true,
    inputAutoTrim: true,
    inputAttributes: {},
    inputValidator: undefined,
    returnInputValueOnDeny: false,
    validationMessage: undefined,
    grow: false,
    position: 'center',
    progressSteps: [],
    currentProgressStep: undefined,
    progressStepsDistance: undefined,
    willOpen: undefined,
    didOpen: undefined,
    didRender: undefined,
    willClose: undefined,
    didClose: undefined,
    didDestroy: undefined,
    scrollbarPadding: true,
    topLayer: false
};
const updatableParams = [
    'allowEscapeKey',
    'allowOutsideClick',
    'background',
    'buttonsStyling',
    'cancelButtonAriaLabel',
    'cancelButtonColor',
    'cancelButtonText',
    'closeButtonAriaLabel',
    'closeButtonHtml',
    'color',
    'confirmButtonAriaLabel',
    'confirmButtonColor',
    'confirmButtonText',
    'currentProgressStep',
    'customClass',
    'denyButtonAriaLabel',
    'denyButtonColor',
    'denyButtonText',
    'didClose',
    'didDestroy',
    'draggable',
    'footer',
    'hideClass',
    'html',
    'icon',
    'iconColor',
    'iconHtml',
    'imageAlt',
    'imageHeight',
    'imageUrl',
    'imageWidth',
    'preConfirm',
    'preDeny',
    'progressSteps',
    'returnFocus',
    'reverseButtons',
    'showCancelButton',
    'showCloseButton',
    'showConfirmButton',
    'showDenyButton',
    'text',
    'title',
    'titleText',
    'theme',
    'willClose'
];
/** @type {Record<string, string | undefined>} */ const deprecatedParams = {
    allowEnterKey: undefined
};
const toastIncompatibleParams = [
    'allowOutsideClick',
    'allowEnterKey',
    'backdrop',
    'draggable',
    'focusConfirm',
    'focusDeny',
    'focusCancel',
    'returnFocus',
    'heightAuto',
    'keydownListenerCapture'
];
/**
 * Is valid parameter
 *
 * @param {string} paramName
 * @returns {boolean}
 */ const isValidParameter = (paramName)=>{
    return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
};
/**
 * Is valid parameter for Swal.update() method
 *
 * @param {string} paramName
 * @returns {boolean}
 */ const isUpdatableParameter = (paramName)=>{
    return updatableParams.indexOf(paramName) !== -1;
};
/**
 * Is deprecated parameter
 *
 * @param {string} paramName
 * @returns {string | undefined}
 */ const isDeprecatedParameter = (paramName)=>{
    return deprecatedParams[paramName];
};
/**
 * @param {string} param
 */ const checkIfParamIsValid = (param)=>{
    if (!isValidParameter(param)) {
        warn(`Unknown parameter "${param}"`);
    }
};
/**
 * @param {string} param
 */ const checkIfToastParamIsValid = (param)=>{
    if (toastIncompatibleParams.includes(param)) {
        warn(`The parameter "${param}" is incompatible with toasts`);
    }
};
/**
 * @param {string} param
 */ const checkIfParamIsDeprecated = (param)=>{
    const isDeprecated = isDeprecatedParameter(param);
    if (isDeprecated) {
        warnAboutDeprecation(param, isDeprecated);
    }
};
/**
 * Show relevant warnings for given params
 *
 * @param {SweetAlertOptions} params
 */ const showWarningsForParams = (params)=>{
    if (params.backdrop === false && params.allowOutsideClick) {
        warn('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
    }
    if (params.theme && ![
        'light',
        'dark',
        'auto',
        'minimal',
        'borderless',
        'embed-iframe'
    ].includes(params.theme)) {
        warn(`Invalid theme "${params.theme}". Expected "light", "dark", "auto", "minimal", "borderless", or "embed-iframe"`);
    }
    for(const param in params){
        checkIfParamIsValid(param);
        if (params.toast) {
            checkIfToastParamIsValid(param);
        }
        checkIfParamIsDeprecated(param);
    }
};
/**
 * Updates popup parameters.
 *
 * @param {SweetAlertOptions} params
 */ function update(params) {
    const container = getContainer();
    const popup = getPopup();
    const innerParams = privateProps.innerParams.get(this);
    if (!popup || hasClass(popup, innerParams.hideClass.popup)) {
        warn(`You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.`);
        return;
    }
    const validUpdatableParams = filterValidParams(params);
    const updatedParams = Object.assign({}, innerParams, validUpdatableParams);
    showWarningsForParams(updatedParams);
    container.dataset['swal2Theme'] = updatedParams.theme;
    render(this, updatedParams);
    privateProps.innerParams.set(this, updatedParams);
    Object.defineProperties(this, {
        params: {
            value: Object.assign({}, this.params, params),
            writable: false,
            enumerable: true
        }
    });
}
/**
 * @param {SweetAlertOptions} params
 * @returns {SweetAlertOptions}
 */ const filterValidParams = (params)=>{
    const validUpdatableParams = {};
    Object.keys(params).forEach((param)=>{
        if (isUpdatableParameter(param)) {
            validUpdatableParams[param] = params[param];
        } else {
            warn(`Invalid parameter to update: ${param}`);
        }
    });
    return validUpdatableParams;
};
/**
 * Dispose the current SweetAlert2 instance
 */ function _destroy() {
    const domCache = privateProps.domCache.get(this);
    const innerParams = privateProps.innerParams.get(this);
    if (!innerParams) {
        disposeWeakMaps(this); // The WeakMaps might have been partly destroyed, we must recall it to dispose any remaining WeakMaps #2335
        return; // This instance has already been destroyed
    }
    // Check if there is another Swal closing
    if (domCache.popup && globalState.swalCloseEventFinishedCallback) {
        globalState.swalCloseEventFinishedCallback();
        delete globalState.swalCloseEventFinishedCallback;
    }
    if (typeof innerParams.didDestroy === 'function') {
        innerParams.didDestroy();
    }
    globalState.eventEmitter.emit('didDestroy');
    disposeSwal(this);
}
/**
 * @param {SweetAlert} instance
 */ const disposeSwal = (instance)=>{
    disposeWeakMaps(instance);
    // Unset this.params so GC will dispose it (#1569)
    delete instance.params;
    // Unset globalState props so GC will dispose globalState (#1569)
    delete globalState.keydownHandler;
    delete globalState.keydownTarget;
    // Unset currentInstance
    delete globalState.currentInstance;
};
/**
 * @param {SweetAlert} instance
 */ const disposeWeakMaps = (instance)=>{
    // If the current instance is awaiting a promise result, we keep the privateMethods to call them once the promise result is retrieved #2335
    if (instance.isAwaitingPromise) {
        unsetWeakMaps(privateProps, instance);
        instance.isAwaitingPromise = true;
    } else {
        unsetWeakMaps(privateMethods, instance);
        unsetWeakMaps(privateProps, instance);
        delete instance.isAwaitingPromise;
        // Unset instance methods
        delete instance.disableButtons;
        delete instance.enableButtons;
        delete instance.getInput;
        delete instance.disableInput;
        delete instance.enableInput;
        delete instance.hideLoading;
        delete instance.disableLoading;
        delete instance.showValidationMessage;
        delete instance.resetValidationMessage;
        delete instance.close;
        delete instance.closePopup;
        delete instance.closeModal;
        delete instance.closeToast;
        delete instance.rejectPromise;
        delete instance.update;
        delete instance._destroy;
    }
};
/**
 * @param {object} obj
 * @param {SweetAlert} instance
 */ const unsetWeakMaps = (obj, instance)=>{
    for(const i in obj){
        obj[i].delete(instance);
    }
};
var instanceMethods = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    _destroy: _destroy,
    close: close,
    closeModal: close,
    closePopup: close,
    closeToast: close,
    disableButtons: disableButtons,
    disableInput: disableInput,
    disableLoading: hideLoading,
    enableButtons: enableButtons,
    enableInput: enableInput,
    getInput: getInput,
    handleAwaitingPromise: handleAwaitingPromise,
    hideLoading: hideLoading,
    rejectPromise: rejectPromise,
    resetValidationMessage: resetValidationMessage,
    showValidationMessage: showValidationMessage,
    update: update
});
/**
 * @param {SweetAlertOptions} innerParams
 * @param {DomCache} domCache
 * @param {Function} dismissWith
 */ const handlePopupClick = (innerParams, domCache, dismissWith)=>{
    if (innerParams.toast) {
        handleToastClick(innerParams, domCache, dismissWith);
    } else {
        // Ignore click events that had mousedown on the popup but mouseup on the container
        // This can happen when the user drags a slider
        handleModalMousedown(domCache);
        // Ignore click events that had mousedown on the container but mouseup on the popup
        handleContainerMousedown(domCache);
        handleModalClick(innerParams, domCache, dismissWith);
    }
};
/**
 * @param {SweetAlertOptions} innerParams
 * @param {DomCache} domCache
 * @param {Function} dismissWith
 */ const handleToastClick = (innerParams, domCache, dismissWith)=>{
    // Closing toast by internal click
    domCache.popup.onclick = ()=>{
        if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {
            return;
        }
        dismissWith(DismissReason.close);
    };
};
/**
 * @param {SweetAlertOptions} innerParams
 * @returns {boolean}
 */ const isAnyButtonShown = (innerParams)=>{
    return !!(innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton);
};
let ignoreOutsideClick = false;
/**
 * @param {DomCache} domCache
 */ const handleModalMousedown = (domCache)=>{
    domCache.popup.onmousedown = ()=>{
        domCache.container.onmouseup = function(e) {
            domCache.container.onmouseup = ()=>{};
            // We only check if the mouseup target is the container because usually it doesn't
            // have any other direct children aside of the popup
            if (e.target === domCache.container) {
                ignoreOutsideClick = true;
            }
        };
    };
};
/**
 * @param {DomCache} domCache
 */ const handleContainerMousedown = (domCache)=>{
    domCache.container.onmousedown = (e)=>{
        // prevent the modal text from being selected on double click on the container (allowOutsideClick: false)
        if (e.target === domCache.container) {
            e.preventDefault();
        }
        domCache.popup.onmouseup = function(e) {
            domCache.popup.onmouseup = ()=>{};
            // We also need to check if the mouseup target is a child of the popup
            if (e.target === domCache.popup || e.target instanceof HTMLElement && domCache.popup.contains(e.target)) {
                ignoreOutsideClick = true;
            }
        };
    };
};
/**
 * @param {SweetAlertOptions} innerParams
 * @param {DomCache} domCache
 * @param {Function} dismissWith
 */ const handleModalClick = (innerParams, domCache, dismissWith)=>{
    domCache.container.onclick = (e)=>{
        if (ignoreOutsideClick) {
            ignoreOutsideClick = false;
            return;
        }
        if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {
            dismissWith(DismissReason.backdrop);
        }
    };
};
const isJqueryElement = (elem)=>typeof elem === 'object' && elem.jquery;
const isElement = (elem)=>elem instanceof Element || isJqueryElement(elem);
const argsToParams = (args)=>{
    const params = {};
    if (typeof args[0] === 'object' && !isElement(args[0])) {
        Object.assign(params, args[0]);
    } else {
        [
            'title',
            'html',
            'icon'
        ].forEach((name, index)=>{
            const arg = args[index];
            if (typeof arg === 'string' || isElement(arg)) {
                params[name] = arg;
            } else if (arg !== undefined) {
                error(`Unexpected type of ${name}! Expected "string" or "Element", got ${typeof arg}`);
            }
        });
    }
    return params;
};
/**
 * Main method to create a new SweetAlert2 popup
 *
 * @param  {...SweetAlertOptions} args
 * @returns {Promise<SweetAlertResult>}
 */ function fire() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    return new this(...args);
}
/**
 * Returns an extended version of `Swal` containing `params` as defaults.
 * Useful for reusing Swal configuration.
 *
 * For example:
 *
 * Before:
 * const textPromptOptions = { input: 'text', showCancelButton: true }
 * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: 'What is your first name?' })
 * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: 'What is your last name?' })
 *
 * After:
 * const TextPrompt = Swal.mixin({ input: 'text', showCancelButton: true })
 * const {value: firstName} = await TextPrompt('What is your first name?')
 * const {value: lastName} = await TextPrompt('What is your last name?')
 *
 * @param {SweetAlertOptions} mixinParams
 * @returns {SweetAlert}
 */ function mixin(mixinParams) {
    class MixinSwal extends this {
        _main(params, priorityMixinParams) {
            return super._main(params, Object.assign({}, mixinParams, priorityMixinParams));
        }
    }
    // @ts-ignore
    return MixinSwal;
}
/**
 * If `timer` parameter is set, returns number of milliseconds of timer remained.
 * Otherwise, returns undefined.
 *
 * @returns {number | undefined}
 */ const getTimerLeft = ()=>{
    return globalState.timeout && globalState.timeout.getTimerLeft();
};
/**
 * Stop timer. Returns number of milliseconds of timer remained.
 * If `timer` parameter isn't set, returns undefined.
 *
 * @returns {number | undefined}
 */ const stopTimer = ()=>{
    if (globalState.timeout) {
        stopTimerProgressBar();
        return globalState.timeout.stop();
    }
};
/**
 * Resume timer. Returns number of milliseconds of timer remained.
 * If `timer` parameter isn't set, returns undefined.
 *
 * @returns {number | undefined}
 */ const resumeTimer = ()=>{
    if (globalState.timeout) {
        const remaining = globalState.timeout.start();
        animateTimerProgressBar(remaining);
        return remaining;
    }
};
/**
 * Resume timer. Returns number of milliseconds of timer remained.
 * If `timer` parameter isn't set, returns undefined.
 *
 * @returns {number | undefined}
 */ const toggleTimer = ()=>{
    const timer = globalState.timeout;
    return timer && (timer.running ? stopTimer() : resumeTimer());
};
/**
 * Increase timer. Returns number of milliseconds of an updated timer.
 * If `timer` parameter isn't set, returns undefined.
 *
 * @param {number} ms
 * @returns {number | undefined}
 */ const increaseTimer = (ms)=>{
    if (globalState.timeout) {
        const remaining = globalState.timeout.increase(ms);
        animateTimerProgressBar(remaining, true);
        return remaining;
    }
};
/**
 * Check if timer is running. Returns true if timer is running
 * or false if timer is paused or stopped.
 * If `timer` parameter isn't set, returns undefined
 *
 * @returns {boolean}
 */ const isTimerRunning = ()=>{
    return !!(globalState.timeout && globalState.timeout.isRunning());
};
let bodyClickListenerAdded = false;
const clickHandlers = {};
/**
 * @param {string} attr
 */ function bindClickHandler() {
    let attr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'data-swal-template';
    clickHandlers[attr] = this;
    if (!bodyClickListenerAdded) {
        document.body.addEventListener('click', bodyClickListener);
        bodyClickListenerAdded = true;
    }
}
const bodyClickListener = (event)=>{
    for(let el = event.target; el && el !== document; el = el.parentNode){
        for(const attr in clickHandlers){
            const template = el.getAttribute(attr);
            if (template) {
                clickHandlers[attr].fire({
                    template
                });
                return;
            }
        }
    }
};
// Source: https://gist.github.com/mudge/5830382?permalink_comment_id=2691957#gistcomment-2691957
class EventEmitter {
    constructor(){
        /** @type {Events} */ this.events = {};
    }
    /**
   * @param {string} eventName
   * @returns {EventHandlers}
   */ _getHandlersByEventName(eventName) {
        if (typeof this.events[eventName] === 'undefined') {
            // not Set because we need to keep the FIFO order
            // https://github.com/sweetalert2/sweetalert2/pull/2763#discussion_r1748990334
            this.events[eventName] = [];
        }
        return this.events[eventName];
    }
    /**
   * @param {string} eventName
   * @param {EventHandler} eventHandler
   */ on(eventName, eventHandler) {
        const currentHandlers = this._getHandlersByEventName(eventName);
        if (!currentHandlers.includes(eventHandler)) {
            currentHandlers.push(eventHandler);
        }
    }
    /**
   * @param {string} eventName
   * @param {EventHandler} eventHandler
   */ once(eventName, eventHandler) {
        var _this = this;
        /**
     * @param {Array} args
     */ const onceFn = function() {
            _this.removeListener(eventName, onceFn);
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            eventHandler.apply(_this, args);
        };
        this.on(eventName, onceFn);
    }
    /**
   * @param {string} eventName
   * @param {Array} args
   */ emit(eventName) {
        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
            args[_key2 - 1] = arguments[_key2];
        }
        this._getHandlersByEventName(eventName).forEach(/**
     * @param {EventHandler} eventHandler
     */ (eventHandler)=>{
            try {
                eventHandler.apply(this, args);
            } catch (error) {
                console.error(error);
            }
        });
    }
    /**
   * @param {string} eventName
   * @param {EventHandler} eventHandler
   */ removeListener(eventName, eventHandler) {
        const currentHandlers = this._getHandlersByEventName(eventName);
        const index = currentHandlers.indexOf(eventHandler);
        if (index > -1) {
            currentHandlers.splice(index, 1);
        }
    }
    /**
   * @param {string} eventName
   */ removeAllListeners(eventName) {
        if (this.events[eventName] !== undefined) {
            // https://github.com/sweetalert2/sweetalert2/pull/2763#discussion_r1749239222
            this.events[eventName].length = 0;
        }
    }
    reset() {
        this.events = {};
    }
}
globalState.eventEmitter = new EventEmitter();
/**
 * @param {string} eventName
 * @param {EventHandler} eventHandler
 */ const on = (eventName, eventHandler)=>{
    globalState.eventEmitter.on(eventName, eventHandler);
};
/**
 * @param {string} eventName
 * @param {EventHandler} eventHandler
 */ const once = (eventName, eventHandler)=>{
    globalState.eventEmitter.once(eventName, eventHandler);
};
/**
 * @param {string} [eventName]
 * @param {EventHandler} [eventHandler]
 */ const off = (eventName, eventHandler)=>{
    // Remove all handlers for all events
    if (!eventName) {
        globalState.eventEmitter.reset();
        return;
    }
    if (eventHandler) {
        // Remove a specific handler
        globalState.eventEmitter.removeListener(eventName, eventHandler);
    } else {
        // Remove all handlers for a specific event
        globalState.eventEmitter.removeAllListeners(eventName);
    }
};
var staticMethods = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    argsToParams: argsToParams,
    bindClickHandler: bindClickHandler,
    clickCancel: clickCancel,
    clickConfirm: clickConfirm,
    clickDeny: clickDeny,
    enableLoading: showLoading,
    fire: fire,
    getActions: getActions,
    getCancelButton: getCancelButton,
    getCloseButton: getCloseButton,
    getConfirmButton: getConfirmButton,
    getContainer: getContainer,
    getDenyButton: getDenyButton,
    getFocusableElements: getFocusableElements,
    getFooter: getFooter,
    getHtmlContainer: getHtmlContainer,
    getIcon: getIcon,
    getIconContent: getIconContent,
    getImage: getImage,
    getInputLabel: getInputLabel,
    getLoader: getLoader,
    getPopup: getPopup,
    getProgressSteps: getProgressSteps,
    getTimerLeft: getTimerLeft,
    getTimerProgressBar: getTimerProgressBar,
    getTitle: getTitle,
    getValidationMessage: getValidationMessage,
    increaseTimer: increaseTimer,
    isDeprecatedParameter: isDeprecatedParameter,
    isLoading: isLoading,
    isTimerRunning: isTimerRunning,
    isUpdatableParameter: isUpdatableParameter,
    isValidParameter: isValidParameter,
    isVisible: isVisible,
    mixin: mixin,
    off: off,
    on: on,
    once: once,
    resumeTimer: resumeTimer,
    showLoading: showLoading,
    stopTimer: stopTimer,
    toggleTimer: toggleTimer
});
class Timer {
    /**
   * @param {Function} callback
   * @param {number} delay
   */ constructor(callback, delay){
        this.callback = callback;
        this.remaining = delay;
        this.running = false;
        this.start();
    }
    /**
   * @returns {number}
   */ start() {
        if (!this.running) {
            this.running = true;
            this.started = new Date();
            this.id = setTimeout(this.callback, this.remaining);
        }
        return this.remaining;
    }
    /**
   * @returns {number}
   */ stop() {
        if (this.started && this.running) {
            this.running = false;
            clearTimeout(this.id);
            this.remaining -= new Date().getTime() - this.started.getTime();
        }
        return this.remaining;
    }
    /**
   * @param {number} n
   * @returns {number}
   */ increase(n) {
        const running = this.running;
        if (running) {
            this.stop();
        }
        this.remaining += n;
        if (running) {
            this.start();
        }
        return this.remaining;
    }
    /**
   * @returns {number}
   */ getTimerLeft() {
        if (this.running) {
            this.stop();
            this.start();
        }
        return this.remaining;
    }
    /**
   * @returns {boolean}
   */ isRunning() {
        return this.running;
    }
}
const swalStringParams = [
    'swal-title',
    'swal-html',
    'swal-footer'
];
/**
 * @param {SweetAlertOptions} params
 * @returns {SweetAlertOptions}
 */ const getTemplateParams = (params)=>{
    const template = typeof params.template === 'string' ? /** @type {HTMLTemplateElement} */ document.querySelector(params.template) : params.template;
    if (!template) {
        return {};
    }
    /** @type {DocumentFragment} */ const templateContent = template.content;
    showWarningsForElements(templateContent);
    const result = Object.assign(getSwalParams(templateContent), getSwalFunctionParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));
    return result;
};
/**
 * @param {DocumentFragment} templateContent
 * @returns {Record<string, any>}
 */ const getSwalParams = (templateContent)=>{
    /** @type {Record<string, any>} */ const result = {};
    /** @type {HTMLElement[]} */ const swalParams = Array.from(templateContent.querySelectorAll('swal-param'));
    swalParams.forEach((param)=>{
        showWarningsForAttributes(param, [
            'name',
            'value'
        ]);
        const paramName = /** @type {keyof SweetAlertOptions} */ param.getAttribute('name');
        const value = param.getAttribute('value');
        if (!paramName || !value) {
            return;
        }
        if (typeof defaultParams[paramName] === 'boolean') {
            result[paramName] = value !== 'false';
        } else if (typeof defaultParams[paramName] === 'object') {
            result[paramName] = JSON.parse(value);
        } else {
            result[paramName] = value;
        }
    });
    return result;
};
/**
 * @param {DocumentFragment} templateContent
 * @returns {Record<string, any>}
 */ const getSwalFunctionParams = (templateContent)=>{
    /** @type {Record<string, any>} */ const result = {};
    /** @type {HTMLElement[]} */ const swalFunctions = Array.from(templateContent.querySelectorAll('swal-function-param'));
    swalFunctions.forEach((param)=>{
        const paramName = /** @type {keyof SweetAlertOptions} */ param.getAttribute('name');
        const value = param.getAttribute('value');
        if (!paramName || !value) {
            return;
        }
        result[paramName] = new Function(`return ${value}`)();
    });
    return result;
};
/**
 * @param {DocumentFragment} templateContent
 * @returns {Record<string, any>}
 */ const getSwalButtons = (templateContent)=>{
    /** @type {Record<string, any>} */ const result = {};
    /** @type {HTMLElement[]} */ const swalButtons = Array.from(templateContent.querySelectorAll('swal-button'));
    swalButtons.forEach((button)=>{
        showWarningsForAttributes(button, [
            'type',
            'color',
            'aria-label'
        ]);
        const type = button.getAttribute('type');
        if (!type || ![
            'confirm',
            'cancel',
            'deny'
        ].includes(type)) {
            return;
        }
        result[`${type}ButtonText`] = button.innerHTML;
        result[`show${capitalizeFirstLetter(type)}Button`] = true;
        if (button.hasAttribute('color')) {
            result[`${type}ButtonColor`] = button.getAttribute('color');
        }
        if (button.hasAttribute('aria-label')) {
            result[`${type}ButtonAriaLabel`] = button.getAttribute('aria-label');
        }
    });
    return result;
};
/**
 * @param {DocumentFragment} templateContent
 * @returns {Pick<SweetAlertOptions, 'imageUrl' | 'imageWidth' | 'imageHeight' | 'imageAlt'>}
 */ const getSwalImage = (templateContent)=>{
    const result = {};
    /** @type {HTMLElement | null} */ const image = templateContent.querySelector('swal-image');
    if (image) {
        showWarningsForAttributes(image, [
            'src',
            'width',
            'height',
            'alt'
        ]);
        if (image.hasAttribute('src')) {
            result.imageUrl = image.getAttribute('src') || undefined;
        }
        if (image.hasAttribute('width')) {
            result.imageWidth = image.getAttribute('width') || undefined;
        }
        if (image.hasAttribute('height')) {
            result.imageHeight = image.getAttribute('height') || undefined;
        }
        if (image.hasAttribute('alt')) {
            result.imageAlt = image.getAttribute('alt') || undefined;
        }
    }
    return result;
};
/**
 * @param {DocumentFragment} templateContent
 * @returns {Record<string, any>}
 */ const getSwalIcon = (templateContent)=>{
    const result = {};
    /** @type {HTMLElement | null} */ const icon = templateContent.querySelector('swal-icon');
    if (icon) {
        showWarningsForAttributes(icon, [
            'type',
            'color'
        ]);
        if (icon.hasAttribute('type')) {
            result.icon = icon.getAttribute('type');
        }
        if (icon.hasAttribute('color')) {
            result.iconColor = icon.getAttribute('color');
        }
        result.iconHtml = icon.innerHTML;
    }
    return result;
};
/**
 * @param {DocumentFragment} templateContent
 * @returns {Record<string, any>}
 */ const getSwalInput = (templateContent)=>{
    /** @type {Record<string, any>} */ const result = {};
    /** @type {HTMLElement | null} */ const input = templateContent.querySelector('swal-input');
    if (input) {
        showWarningsForAttributes(input, [
            'type',
            'label',
            'placeholder',
            'value'
        ]);
        result.input = input.getAttribute('type') || 'text';
        if (input.hasAttribute('label')) {
            result.inputLabel = input.getAttribute('label');
        }
        if (input.hasAttribute('placeholder')) {
            result.inputPlaceholder = input.getAttribute('placeholder');
        }
        if (input.hasAttribute('value')) {
            result.inputValue = input.getAttribute('value');
        }
    }
    /** @type {HTMLElement[]} */ const inputOptions = Array.from(templateContent.querySelectorAll('swal-input-option'));
    if (inputOptions.length) {
        result.inputOptions = {};
        inputOptions.forEach((option)=>{
            showWarningsForAttributes(option, [
                'value'
            ]);
            const optionValue = option.getAttribute('value');
            if (!optionValue) {
                return;
            }
            const optionName = option.innerHTML;
            result.inputOptions[optionValue] = optionName;
        });
    }
    return result;
};
/**
 * @param {DocumentFragment} templateContent
 * @param {string[]} paramNames
 * @returns {Record<string, any>}
 */ const getSwalStringParams = (templateContent, paramNames)=>{
    /** @type {Record<string, any>} */ const result = {};
    for(const i in paramNames){
        const paramName = paramNames[i];
        /** @type {HTMLElement | null} */ const tag = templateContent.querySelector(paramName);
        if (tag) {
            showWarningsForAttributes(tag, []);
            result[paramName.replace(/^swal-/, '')] = tag.innerHTML.trim();
        }
    }
    return result;
};
/**
 * @param {DocumentFragment} templateContent
 */ const showWarningsForElements = (templateContent)=>{
    const allowedElements = swalStringParams.concat([
        'swal-param',
        'swal-function-param',
        'swal-button',
        'swal-image',
        'swal-icon',
        'swal-input',
        'swal-input-option'
    ]);
    Array.from(templateContent.children).forEach((el)=>{
        const tagName = el.tagName.toLowerCase();
        if (!allowedElements.includes(tagName)) {
            warn(`Unrecognized element <${tagName}>`);
        }
    });
};
/**
 * @param {HTMLElement} el
 * @param {string[]} allowedAttributes
 */ const showWarningsForAttributes = (el, allowedAttributes)=>{
    Array.from(el.attributes).forEach((attribute)=>{
        if (allowedAttributes.indexOf(attribute.name) === -1) {
            warn([
                `Unrecognized attribute "${attribute.name}" on <${el.tagName.toLowerCase()}>.`,
                `${allowedAttributes.length ? `Allowed attributes are: ${allowedAttributes.join(', ')}` : 'To set the value, use HTML within the element.'}`
            ]);
        }
    });
};
const SHOW_CLASS_TIMEOUT = 10;
/**
 * Open popup, add necessary classes and styles, fix scrollbar
 *
 * @param {SweetAlertOptions} params
 */ const openPopup = (params)=>{
    const container = getContainer();
    const popup = getPopup();
    if (typeof params.willOpen === 'function') {
        params.willOpen(popup);
    }
    globalState.eventEmitter.emit('willOpen', popup);
    const bodyStyles = window.getComputedStyle(document.body);
    const initialBodyOverflow = bodyStyles.overflowY;
    addClasses(container, popup, params);
    // scrolling is 'hidden' until animation is done, after that 'auto'
    setTimeout(()=>{
        setScrollingVisibility(container, popup);
    }, SHOW_CLASS_TIMEOUT);
    if (isModal()) {
        fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);
        setAriaHidden();
    }
    if (!isToast() && !globalState.previousActiveElement) {
        globalState.previousActiveElement = document.activeElement;
    }
    if (typeof params.didOpen === 'function') {
        setTimeout(()=>params.didOpen(popup));
    }
    globalState.eventEmitter.emit('didOpen', popup);
    removeClass(container, swalClasses['no-transition']);
};
/**
 * @param {AnimationEvent} event
 */ const swalOpenAnimationFinished = (event)=>{
    const popup = getPopup();
    if (event.target !== popup) {
        return;
    }
    const container = getContainer();
    popup.removeEventListener('animationend', swalOpenAnimationFinished);
    popup.removeEventListener('transitionend', swalOpenAnimationFinished);
    container.style.overflowY = 'auto';
};
/**
 * @param {HTMLElement} container
 * @param {HTMLElement} popup
 */ const setScrollingVisibility = (container, popup)=>{
    if (hasCssAnimation(popup)) {
        container.style.overflowY = 'hidden';
        popup.addEventListener('animationend', swalOpenAnimationFinished);
        popup.addEventListener('transitionend', swalOpenAnimationFinished);
    } else {
        container.style.overflowY = 'auto';
    }
};
/**
 * @param {HTMLElement} container
 * @param {boolean} scrollbarPadding
 * @param {string} initialBodyOverflow
 */ const fixScrollContainer = (container, scrollbarPadding, initialBodyOverflow)=>{
    iOSfix();
    if (scrollbarPadding && initialBodyOverflow !== 'hidden') {
        replaceScrollbarWithPadding(initialBodyOverflow);
    }
    // sweetalert2/issues/1247
    setTimeout(()=>{
        container.scrollTop = 0;
    });
};
/**
 * @param {HTMLElement} container
 * @param {HTMLElement} popup
 * @param {SweetAlertOptions} params
 */ const addClasses = (container, popup, params)=>{
    addClass(container, params.showClass.backdrop);
    if (params.animation) {
        // this workaround with opacity is needed for https://github.com/sweetalert2/sweetalert2/issues/2059
        popup.style.setProperty('opacity', '0', 'important');
        show(popup, 'grid');
        setTimeout(()=>{
            // Animate popup right after showing it
            addClass(popup, params.showClass.popup);
            // and remove the opacity workaround
            popup.style.removeProperty('opacity');
        }, SHOW_CLASS_TIMEOUT); // 10ms in order to fix #2062
    } else {
        show(popup, 'grid');
    }
    addClass([
        document.documentElement,
        document.body
    ], swalClasses.shown);
    if (params.heightAuto && params.backdrop && !params.toast) {
        addClass([
            document.documentElement,
            document.body
        ], swalClasses['height-auto']);
    }
};
var defaultInputValidators = {
    /**
   * @param {string} string
   * @param {string} [validationMessage]
   * @returns {Promise<string | void>}
   */ email: (string, validationMessage)=>{
        return /^[a-zA-Z0-9.+_'-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]+$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid email address');
    },
    /**
   * @param {string} string
   * @param {string} [validationMessage]
   * @returns {Promise<string | void>}
   */ url: (string, validationMessage)=>{
        // taken from https://stackoverflow.com/a/3809435 with a small change from #1306 and #2013
        return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid URL');
    }
};
/**
 * @param {SweetAlertOptions} params
 */ function setDefaultInputValidators(params) {
    // Use default `inputValidator` for supported input types if not provided
    if (params.inputValidator) {
        return;
    }
    if (params.input === 'email') {
        params.inputValidator = defaultInputValidators['email'];
    }
    if (params.input === 'url') {
        params.inputValidator = defaultInputValidators['url'];
    }
}
/**
 * @param {SweetAlertOptions} params
 */ function validateCustomTargetElement(params) {
    // Determine if the custom target element is valid
    if (!params.target || typeof params.target === 'string' && !document.querySelector(params.target) || typeof params.target !== 'string' && !params.target.appendChild) {
        warn('Target parameter is not valid, defaulting to "body"');
        params.target = 'body';
    }
}
/**
 * Set type, text and actions on popup
 *
 * @param {SweetAlertOptions} params
 */ function setParameters(params) {
    setDefaultInputValidators(params);
    // showLoaderOnConfirm && preConfirm
    if (params.showLoaderOnConfirm && !params.preConfirm) {
        warn('showLoaderOnConfirm is set to true, but preConfirm is not defined.\n' + 'showLoaderOnConfirm should be used together with preConfirm, see usage example:\n' + 'https://sweetalert2.github.io/#ajax-request');
    }
    validateCustomTargetElement(params);
    // Replace newlines with <br> in title
    if (typeof params.title === 'string') {
        params.title = params.title.split('\n').join('<br />');
    }
    init(params);
}
/** @type {SweetAlert} */ let currentInstance;
var _promise = /*#__PURE__*/ new WeakMap();
class SweetAlert {
    /**
   * @param {...any} args
   * @this {SweetAlert}
   */ constructor(){
        /**
     * @type {Promise<SweetAlertResult>}
     */ _classPrivateFieldInitSpec(this, _promise, void 0);
        // Prevent run in Node env
        if (typeof window === 'undefined') {
            return;
        }
        currentInstance = this;
        // @ts-ignore
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        const outerParams = Object.freeze(this.constructor.argsToParams(args));
        /** @type {Readonly<SweetAlertOptions>} */ this.params = outerParams;
        /** @type {boolean} */ this.isAwaitingPromise = false;
        _classPrivateFieldSet2(_promise, this, this._main(currentInstance.params));
    }
    _main(userParams) {
        let mixinParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        showWarningsForParams(Object.assign({}, mixinParams, userParams));
        if (globalState.currentInstance) {
            const swalPromiseResolve = privateMethods.swalPromiseResolve.get(globalState.currentInstance);
            const { isAwaitingPromise } = globalState.currentInstance;
            globalState.currentInstance._destroy();
            if (!isAwaitingPromise) {
                swalPromiseResolve({
                    isDismissed: true
                });
            }
            if (isModal()) {
                unsetAriaHidden();
            }
        }
        globalState.currentInstance = currentInstance;
        const innerParams = prepareParams(userParams, mixinParams);
        setParameters(innerParams);
        Object.freeze(innerParams);
        // clear the previous timer
        if (globalState.timeout) {
            globalState.timeout.stop();
            delete globalState.timeout;
        }
        // clear the restore focus timeout
        clearTimeout(globalState.restoreFocusTimeout);
        const domCache = populateDomCache(currentInstance);
        render(currentInstance, innerParams);
        privateProps.innerParams.set(currentInstance, innerParams);
        return swalPromise(currentInstance, domCache, innerParams);
    }
    // `catch` cannot be the name of a module export, so we define our thenable methods here instead
    then(onFulfilled) {
        return _classPrivateFieldGet2(_promise, this).then(onFulfilled);
    }
    finally(onFinally) {
        return _classPrivateFieldGet2(_promise, this).finally(onFinally);
    }
}
/**
 * @param {SweetAlert} instance
 * @param {DomCache} domCache
 * @param {SweetAlertOptions} innerParams
 * @returns {Promise}
 */ const swalPromise = (instance, domCache, innerParams)=>{
    return new Promise((resolve, reject)=>{
        // functions to handle all closings/dismissals
        /**
     * @param {DismissReason} dismiss
     */ const dismissWith = (dismiss)=>{
            instance.close({
                isDismissed: true,
                dismiss
            });
        };
        privateMethods.swalPromiseResolve.set(instance, resolve);
        privateMethods.swalPromiseReject.set(instance, reject);
        domCache.confirmButton.onclick = ()=>{
            handleConfirmButtonClick(instance);
        };
        domCache.denyButton.onclick = ()=>{
            handleDenyButtonClick(instance);
        };
        domCache.cancelButton.onclick = ()=>{
            handleCancelButtonClick(instance, dismissWith);
        };
        domCache.closeButton.onclick = ()=>{
            dismissWith(DismissReason.close);
        };
        handlePopupClick(innerParams, domCache, dismissWith);
        addKeydownHandler(globalState, innerParams, dismissWith);
        handleInputOptionsAndValue(instance, innerParams);
        openPopup(innerParams);
        setupTimer(globalState, innerParams, dismissWith);
        initFocus(domCache, innerParams);
        // Scroll container to top on open (#1247, #1946)
        setTimeout(()=>{
            domCache.container.scrollTop = 0;
        });
    });
};
/**
 * @param {SweetAlertOptions} userParams
 * @param {SweetAlertOptions} mixinParams
 * @returns {SweetAlertOptions}
 */ const prepareParams = (userParams, mixinParams)=>{
    const templateParams = getTemplateParams(userParams);
    const params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams); // precedence is described in #2131
    params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);
    params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);
    if (params.animation === false) {
        params.showClass = {
            backdrop: 'swal2-noanimation'
        };
        params.hideClass = {};
    }
    return params;
};
/**
 * @param {SweetAlert} instance
 * @returns {DomCache}
 */ const populateDomCache = (instance)=>{
    const domCache = {
        popup: getPopup(),
        container: getContainer(),
        actions: getActions(),
        confirmButton: getConfirmButton(),
        denyButton: getDenyButton(),
        cancelButton: getCancelButton(),
        loader: getLoader(),
        closeButton: getCloseButton(),
        validationMessage: getValidationMessage(),
        progressSteps: getProgressSteps()
    };
    privateProps.domCache.set(instance, domCache);
    return domCache;
};
/**
 * @param {GlobalState} globalState
 * @param {SweetAlertOptions} innerParams
 * @param {Function} dismissWith
 */ const setupTimer = (globalState, innerParams, dismissWith)=>{
    const timerProgressBar = getTimerProgressBar();
    hide(timerProgressBar);
    if (innerParams.timer) {
        globalState.timeout = new Timer(()=>{
            dismissWith('timer');
            delete globalState.timeout;
        }, innerParams.timer);
        if (innerParams.timerProgressBar) {
            show(timerProgressBar);
            applyCustomClass(timerProgressBar, innerParams, 'timerProgressBar');
            setTimeout(()=>{
                if (globalState.timeout && globalState.timeout.running) {
                    // timer can be already stopped or unset at this point
                    animateTimerProgressBar(innerParams.timer);
                }
            });
        }
    }
};
/**
 * Initialize focus in the popup:
 *
 * 1. If `toast` is `true`, don't steal focus from the document.
 * 2. Else if there is an [autofocus] element, focus it.
 * 3. Else if `focusConfirm` is `true` and confirm button is visible, focus it.
 * 4. Else if `focusDeny` is `true` and deny button is visible, focus it.
 * 5. Else if `focusCancel` is `true` and cancel button is visible, focus it.
 * 6. Else focus the first focusable element in a popup (if any).
 *
 * @param {DomCache} domCache
 * @param {SweetAlertOptions} innerParams
 */ const initFocus = (domCache, innerParams)=>{
    if (innerParams.toast) {
        return;
    }
    // TODO: this is dumb, remove `allowEnterKey` param in the next major version
    if (!callIfFunction(innerParams.allowEnterKey)) {
        warnAboutDeprecation('allowEnterKey');
        blurActiveElement();
        return;
    }
    if (focusAutofocus(domCache)) {
        return;
    }
    if (focusButton(domCache, innerParams)) {
        return;
    }
    setFocus(-1, 1);
};
/**
 * @param {DomCache} domCache
 * @returns {boolean}
 */ const focusAutofocus = (domCache)=>{
    const autofocusElements = Array.from(domCache.popup.querySelectorAll('[autofocus]'));
    for (const autofocusElement of autofocusElements){
        if (autofocusElement instanceof HTMLElement && isVisible$1(autofocusElement)) {
            autofocusElement.focus();
            return true;
        }
    }
    return false;
};
/**
 * @param {DomCache} domCache
 * @param {SweetAlertOptions} innerParams
 * @returns {boolean}
 */ const focusButton = (domCache, innerParams)=>{
    if (innerParams.focusDeny && isVisible$1(domCache.denyButton)) {
        domCache.denyButton.focus();
        return true;
    }
    if (innerParams.focusCancel && isVisible$1(domCache.cancelButton)) {
        domCache.cancelButton.focus();
        return true;
    }
    if (innerParams.focusConfirm && isVisible$1(domCache.confirmButton)) {
        domCache.confirmButton.focus();
        return true;
    }
    return false;
};
const blurActiveElement = ()=>{
    if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === 'function') {
        document.activeElement.blur();
    }
};
// Dear russian users visiting russian sites. Let's have fun.
if (typeof window !== 'undefined' && /^ru\b/.test(navigator.language) && location.host.match(/\.(ru|su|by|xn--p1ai)$/)) {
    const now = new Date();
    const initiationDate = localStorage.getItem('swal-initiation');
    if (!initiationDate) {
        localStorage.setItem('swal-initiation', `${now}`);
    } else if ((now.getTime() - Date.parse(initiationDate)) / (1000 * 60 * 60 * 24) > 3) {
        setTimeout(()=>{
            document.body.style.pointerEvents = 'none';
            const ukrainianAnthem = document.createElement('audio');
            ukrainianAnthem.src = 'https://flag-gimn.ru/wp-content/uploads/2021/09/Ukraina.mp3';
            ukrainianAnthem.loop = true;
            document.body.appendChild(ukrainianAnthem);
            setTimeout(()=>{
                ukrainianAnthem.play().catch(()=>{
                // ignore
                });
            }, 2500);
        }, 500);
    }
}
// Assign instance methods from src/instanceMethods/*.js to prototype
SweetAlert.prototype.disableButtons = disableButtons;
SweetAlert.prototype.enableButtons = enableButtons;
SweetAlert.prototype.getInput = getInput;
SweetAlert.prototype.disableInput = disableInput;
SweetAlert.prototype.enableInput = enableInput;
SweetAlert.prototype.hideLoading = hideLoading;
SweetAlert.prototype.disableLoading = hideLoading;
SweetAlert.prototype.showValidationMessage = showValidationMessage;
SweetAlert.prototype.resetValidationMessage = resetValidationMessage;
SweetAlert.prototype.close = close;
SweetAlert.prototype.closePopup = close;
SweetAlert.prototype.closeModal = close;
SweetAlert.prototype.closeToast = close;
SweetAlert.prototype.rejectPromise = rejectPromise;
SweetAlert.prototype.update = update;
SweetAlert.prototype._destroy = _destroy;
// Assign static methods from src/staticMethods/*.js to constructor
Object.assign(SweetAlert, staticMethods);
// Proxy to instance methods to constructor, for now, for backwards compatibility
Object.keys(instanceMethods).forEach((key)=>{
    /**
   * @param {...any} args
   * @returns {any | undefined}
   */ SweetAlert[key] = function() {
        if (currentInstance && currentInstance[key]) {
            return currentInstance[key](...arguments);
        }
        return null;
    };
});
SweetAlert.DismissReason = DismissReason;
SweetAlert.version = '11.21.0';
const Swal = SweetAlert;
// @ts-ignore
Swal.default = Swal;
;
"undefined" != typeof document && function(e, t) {
    var n = e.createElement("style");
    if (e.getElementsByTagName("head")[0].appendChild(n), n.styleSheet) n.styleSheet.disabled || (n.styleSheet.cssText = t);
    else try {
        n.innerHTML = t;
    } catch (e) {
        n.innerText = t;
    }
}(document, ":root{--swal2-outline: 0 0 0 3px rgba(100, 150, 200, 0.5);--swal2-container-padding: 0.625em;--swal2-backdrop: rgba(0, 0, 0, 0.4);--swal2-backdrop-transition: background-color 0.1s;--swal2-width: 32em;--swal2-padding: 0 0 1.25em;--swal2-border: none;--swal2-border-radius: 0.3125rem;--swal2-background: white;--swal2-color: #545454;--swal2-footer-border-color: #eee;--swal2-show-animation: swal2-show 0.3s;--swal2-hide-animation: swal2-hide 0.15s forwards;--swal2-icon-zoom: 1;--swal2-icon-animations: true;--swal2-title-padding: 0.8em 1em 0;--swal2-html-container-padding: 1em 1.6em 0.3em;--swal2-input-border-radius: 0.1875em;--swal2-input-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.06), 0 0 0 3px transparent;--swal2-input-background: transparent;--swal2-input-transition: border-color 0.1s, box-shadow 0.1s;--swal2-progress-step-background: #add8e6;--swal2-validation-message-background: #f0f0f0;--swal2-validation-message-color: #666;--swal2-close-button-position: initial;--swal2-close-button-inset: auto;--swal2-close-button-font-size: 2.5em;--swal2-close-button-color: #ccc;--swal2-close-button-transition: color 0.1s, box-shadow 0.1s;--swal2-close-button-outline: initial;--swal2-close-button-box-shadow: inset 0 0 0 3px transparent;--swal2-close-button-focus-box-shadow: inset var(--swal2-outline);--swal2-close-button-hover-transform: none;--swal2-button-darken-hover: rgba(0, 0, 0, 0.1);--swal2-button-darken-active: rgba(0, 0, 0, 0.2);--swal2-button-transition: box-shadow 0.1s;--swal2-confirm-button-border: 0;--swal2-confirm-button-border-radius: 0.25em;--swal2-confirm-button-background-color: #7066e0;--swal2-deny-button-border: 0;--swal2-deny-button-border-radius: 0.25em;--swal2-deny-button-background-color: #dc3741;--swal2-cancel-button-border: 0;--swal2-cancel-button-border-radius: 0.25em;--swal2-cancel-button-background-color: #6e7881;--swal2-toast-show-animation: swal2-toast-show 0.5s;--swal2-toast-hide-animation: swal2-toast-hide 0.1s forwards;--swal2-toast-border: none;--swal2-toast-box-shadow: 0 0 1px hsl(0deg 0% 0% / 0.075), 0 1px 2px hsl(0deg 0% 0% / 0.075), 1px 2px 4px hsl(0deg 0% 0% / 0.075), 1px 3px 8px hsl(0deg 0% 0% / 0.075), 2px 4px 16px hsl(0deg 0% 0% / 0.075)}[data-swal2-theme=dark]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white)}@media(prefers-color-scheme: dark){[data-swal2-theme=auto]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white)}}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px var(--swal2-backdrop)}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{inset:0 auto auto 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{inset:0 0 auto auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{inset:0 auto auto 0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{inset:50% auto auto 0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{inset:50% auto auto 50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{inset:50% 0 auto auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{inset:auto auto 0 0}body.swal2-toast-shown .swal2-container.swal2-bottom{inset:auto auto 0 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{inset:auto 0 0 auto}@media print{body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown) .swal2-container{position:static !important}}div:where(.swal2-container){display:grid;position:fixed;z-index:1060;inset:0;box-sizing:border-box;grid-template-areas:\"top-start     top            top-end\" \"center-start  center         center-end\" \"bottom-start  bottom-center  bottom-end\";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:var(--swal2-container-padding);overflow-x:hidden;transition:var(--swal2-backdrop-transition);-webkit-overflow-scrolling:touch}div:where(.swal2-container).swal2-backdrop-show,div:where(.swal2-container).swal2-noanimation{background:var(--swal2-backdrop)}div:where(.swal2-container).swal2-backdrop-hide{background:rgba(0,0,0,0) !important}div:where(.swal2-container).swal2-top-start,div:where(.swal2-container).swal2-center-start,div:where(.swal2-container).swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}div:where(.swal2-container).swal2-top,div:where(.swal2-container).swal2-center,div:where(.swal2-container).swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}div:where(.swal2-container).swal2-top-end,div:where(.swal2-container).swal2-center-end,div:where(.swal2-container).swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}div:where(.swal2-container).swal2-top-start>.swal2-popup{align-self:start}div:where(.swal2-container).swal2-top>.swal2-popup{grid-column:2;place-self:start center}div:where(.swal2-container).swal2-top-end>.swal2-popup,div:where(.swal2-container).swal2-top-right>.swal2-popup{grid-column:3;place-self:start end}div:where(.swal2-container).swal2-center-start>.swal2-popup,div:where(.swal2-container).swal2-center-left>.swal2-popup{grid-row:2;align-self:center}div:where(.swal2-container).swal2-center>.swal2-popup{grid-column:2;grid-row:2;place-self:center center}div:where(.swal2-container).swal2-center-end>.swal2-popup,div:where(.swal2-container).swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;place-self:center end}div:where(.swal2-container).swal2-bottom-start>.swal2-popup,div:where(.swal2-container).swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}div:where(.swal2-container).swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;place-self:end center}div:where(.swal2-container).swal2-bottom-end>.swal2-popup,div:where(.swal2-container).swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;place-self:end end}div:where(.swal2-container).swal2-grow-row>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}div:where(.swal2-container).swal2-grow-column>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}div:where(.swal2-container).swal2-no-transition{transition:none !important}div:where(.swal2-container)[popover]{width:auto;border:0}div:where(.swal2-container) div:where(.swal2-popup){display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:var(--swal2-width);max-width:100%;padding:var(--swal2-padding);border:var(--swal2-border);border-radius:var(--swal2-border-radius);background:var(--swal2-background);color:var(--swal2-color);font-family:inherit;font-size:1rem;container-name:swal2-popup}div:where(.swal2-container) div:where(.swal2-popup):focus{outline:none}div:where(.swal2-container) div:where(.swal2-popup).swal2-loading{overflow-y:hidden}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable{cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable div:where(.swal2-icon){cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging{cursor:grabbing}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging div:where(.swal2-icon){cursor:grabbing}div:where(.swal2-container) h2:where(.swal2-title){position:relative;max-width:100%;margin:0;padding:var(--swal2-title-padding);color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word;cursor:initial}div:where(.swal2-container) div:where(.swal2-actions){display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:auto;margin:1.25em auto 0;padding:0}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(var(--swal2-button-darken-hover), var(--swal2-button-darken-hover))}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(var(--swal2-button-darken-active), var(--swal2-button-darken-active))}div:where(.swal2-container) div:where(.swal2-loader){display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}div:where(.swal2-container) button:where(.swal2-styled){margin:.3125em;padding:.625em 1.1em;transition:var(--swal2-button-transition);box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}div:where(.swal2-container) button:where(.swal2-styled):not([disabled]){cursor:pointer}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm){border:var(--swal2-confirm-button-border);border-radius:var(--swal2-confirm-button-border-radius);background:initial;background-color:var(--swal2-confirm-button-background-color);color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny){border:var(--swal2-deny-button-border);border-radius:var(--swal2-deny-button-border-radius);background:initial;background-color:var(--swal2-deny-button-background-color);color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel){border:var(--swal2-cancel-button-border);border-radius:var(--swal2-cancel-button-border-radius);background:initial;background-color:var(--swal2-cancel-button-background-color);color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):focus-visible{outline:none;box-shadow:var(--swal2-action-button-outline)}div:where(.swal2-container) button:where(.swal2-styled)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-footer){margin:1em 0 0;padding:1em 1em 0;border-top:1px solid var(--swal2-footer-border-color);color:inherit;font-size:1em;text-align:center;cursor:initial}div:where(.swal2-container) .swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:var(--swal2-border-radius);border-bottom-left-radius:var(--swal2-border-radius)}div:where(.swal2-container) div:where(.swal2-timer-progress-bar){width:100%;height:.25em;background:rgba(0,0,0,.2)}div:where(.swal2-container) img:where(.swal2-image){max-width:100%;margin:2em auto 1em;cursor:initial}div:where(.swal2-container) button:where(.swal2-close){position:var(--swal2-close-button-position);inset:var(--swal2-close-button-inset);z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:var(--swal2-close-button-transition);border:none;border-radius:var(--swal2-border-radius);outline:var(--swal2-close-button-outline);background:rgba(0,0,0,0);color:var(--swal2-close-button-color);font-family:monospace;font-size:var(--swal2-close-button-font-size);cursor:pointer;justify-self:end}div:where(.swal2-container) button:where(.swal2-close):hover{transform:var(--swal2-close-button-hover-transform);background:rgba(0,0,0,0);color:#f27474}div:where(.swal2-container) button:where(.swal2-close):focus-visible{outline:none;box-shadow:var(--swal2-close-button-focus-box-shadow)}div:where(.swal2-container) button:where(.swal2-close)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-html-container){z-index:1;justify-content:center;margin:0;padding:var(--swal2-html-container-padding);overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word;cursor:initial}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea),div:where(.swal2-container) select:where(.swal2-select),div:where(.swal2-container) div:where(.swal2-radio),div:where(.swal2-container) label:where(.swal2-checkbox){margin:1em 2em 3px}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea){box-sizing:border-box;width:auto;transition:var(--swal2-input-transition);border:1px solid #d9d9d9;border-radius:var(--swal2-input-border-radius);background:var(--swal2-input-background);box-shadow:var(--swal2-input-box-shadow);color:inherit;font-size:1.125em}div:where(.swal2-container) input:where(.swal2-input).swal2-inputerror,div:where(.swal2-container) input:where(.swal2-file).swal2-inputerror,div:where(.swal2-container) textarea:where(.swal2-textarea).swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}div:where(.swal2-container) input:where(.swal2-input):focus,div:where(.swal2-container) input:where(.swal2-file):focus,div:where(.swal2-container) textarea:where(.swal2-textarea):focus{border:1px solid #b4dbed;outline:none;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) input:where(.swal2-input)::placeholder,div:where(.swal2-container) input:where(.swal2-file)::placeholder,div:where(.swal2-container) textarea:where(.swal2-textarea)::placeholder{color:#ccc}div:where(.swal2-container) .swal2-range{margin:1em 2em 3px;background:var(--swal2-background)}div:where(.swal2-container) .swal2-range input{width:80%}div:where(.swal2-container) .swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}div:where(.swal2-container) .swal2-range input,div:where(.swal2-container) .swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}div:where(.swal2-container) .swal2-input{height:2.625em;padding:0 .75em}div:where(.swal2-container) .swal2-file{width:75%;margin-right:auto;margin-left:auto;background:var(--swal2-input-background);font-size:1.125em}div:where(.swal2-container) .swal2-textarea{height:6.75em;padding:.75em}div:where(.swal2-container) .swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:var(--swal2-input-background);color:inherit;font-size:1.125em}div:where(.swal2-container) .swal2-radio,div:where(.swal2-container) .swal2-checkbox{align-items:center;justify-content:center;background:var(--swal2-background);color:inherit}div:where(.swal2-container) .swal2-radio label,div:where(.swal2-container) .swal2-checkbox label{margin:0 .6em;font-size:1.125em}div:where(.swal2-container) .swal2-radio input,div:where(.swal2-container) .swal2-checkbox input{flex-shrink:0;margin:0 .4em}div:where(.swal2-container) label:where(.swal2-input-label){display:flex;justify-content:center;margin:1em auto 0}div:where(.swal2-container) div:where(.swal2-validation-message){align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:var(--swal2-validation-message-background);color:var(--swal2-validation-message-color);font-size:1em;font-weight:300}div:where(.swal2-container) div:where(.swal2-validation-message)::before{content:\"!\";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}div:where(.swal2-container) .swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}div:where(.swal2-container) .swal2-progress-steps li{display:inline-block;position:relative}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:var(--swal2-progress-step-background);color:#fff}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:var(--swal2-progress-step-background)}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}div:where(.swal2-icon){position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;zoom:var(--swal2-icon-zoom);border:.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}div:where(.swal2-icon) .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}div:where(.swal2-icon).swal2-error{border-color:#f27474;color:#f27474}div:where(.swal2-icon).swal2-error .swal2-x-mark{position:relative;flex-grow:1}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}}div:where(.swal2-icon).swal2-warning{border-color:#f8bb86;color:#f8bb86}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}}div:where(.swal2-icon).swal2-info{border-color:#3fc3ee;color:#3fc3ee}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}}div:where(.swal2-icon).swal2-question{border-color:#87adbd;color:#87adbd}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}}div:where(.swal2-icon).swal2-success{border-color:#a5dc86;color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;border-radius:50%}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}div:where(.swal2-icon).swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}div:where(.swal2-icon).swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}@container swal2-popup style(--swal2-icon-animations:true){div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:var(--swal2-show-animation)}.swal2-hide{animation:var(--swal2-hide-animation)}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;border:var(--swal2-toast-border);background:var(--swal2-background);box-shadow:var(--swal2-toast-box-shadow);pointer-events:all}.swal2-toast>*{grid-column:2}.swal2-toast h2:where(.swal2-title){margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-toast .swal2-loading{justify-content:center}.swal2-toast input:where(.swal2-input){height:2em;margin:.5em;font-size:1em}.swal2-toast .swal2-validation-message{font-size:1em}.swal2-toast div:where(.swal2-footer){margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-toast button:where(.swal2-close){grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-toast div:where(.swal2-html-container){margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-toast div:where(.swal2-html-container):empty{padding:0}.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-toast div:where(.swal2-actions){justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-toast button:where(.swal2-styled){margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;border-radius:50%}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}@container swal2-popup style(--swal2-icon-animations:true){.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}}.swal2-toast.swal2-show{animation:var(--swal2-toast-show-animation)}.swal2-toast.swal2-hide{animation:var(--swal2-toast-hide-animation)}@keyframes swal2-show{0%{transform:scale(0.7)}45%{transform:scale(1.05)}80%{transform:scale(0.95)}100%{transform:scale(1)}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(0.5);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}");
}}),
"[project]/node_modules/bootstrap/dist/js/bootstrap.bundle.min.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
  * Bootstrap v5.3.5 (https://getbootstrap.com/)
  * Copyright 2011-2025 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */ !function(t, e) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = e() : ("TURBOPACK unreachable", undefined);
}(this, function() {
    "use strict";
    const t = new Map, e = {
        set (e, i, n) {
            t.has(e) || t.set(e, new Map);
            const s = t.get(e);
            s.has(i) || 0 === s.size ? s.set(i, n) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`);
        },
        get: (e, i)=>t.has(e) && t.get(e).get(i) || null,
        remove (e, i) {
            if (!t.has(e)) return;
            const n = t.get(e);
            n.delete(i), 0 === n.size && t.delete(e);
        }
    }, i = "transitionend", n = (t)=>(t && window.CSS && window.CSS.escape && (t = t.replace(/#([^\s"#']+)/g, (t, e)=>`#${CSS.escape(e)}`)), t), s = (t)=>{
        t.dispatchEvent(new Event(i));
    }, o = (t)=>!(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType), r = (t)=>o(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(n(t)) : null, a = (t)=>{
        if (!o(t) || 0 === t.getClientRects().length) return !1;
        const e = "visible" === getComputedStyle(t).getPropertyValue("visibility"), i = t.closest("details:not([open])");
        if (!i) return e;
        if (i !== t) {
            const e = t.closest("summary");
            if (e && e.parentNode !== i) return !1;
            if (null === e) return !1;
        }
        return e;
    }, l = (t)=>!t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")), c = (t)=>{
        if (!document.documentElement.attachShadow) return null;
        if ("function" == typeof t.getRootNode) {
            const e = t.getRootNode();
            return e instanceof ShadowRoot ? e : null;
        }
        return t instanceof ShadowRoot ? t : t.parentNode ? c(t.parentNode) : null;
    }, h = ()=>{}, d = (t)=>{
        t.offsetHeight;
    }, u = ()=>window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null, f = [], p = ()=>"rtl" === document.documentElement.dir, m = (t)=>{
        var e;
        e = ()=>{
            const e = u();
            if (e) {
                const i = t.NAME, n = e.fn[i];
                e.fn[i] = t.jQueryInterface, e.fn[i].Constructor = t, e.fn[i].noConflict = ()=>(e.fn[i] = n, t.jQueryInterface);
            }
        }, "loading" === document.readyState ? (f.length || document.addEventListener("DOMContentLoaded", ()=>{
            for (const t of f)t();
        }), f.push(e)) : e();
    }, g = (t, e = [], i = t)=>"function" == typeof t ? t.call(...e) : i, _ = (t, e, n = !0)=>{
        if (!n) return void g(t);
        const o = ((t)=>{
            if (!t) return 0;
            let { transitionDuration: e, transitionDelay: i } = window.getComputedStyle(t);
            const n = Number.parseFloat(e), s = Number.parseFloat(i);
            return n || s ? (e = e.split(",")[0], i = i.split(",")[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(i))) : 0;
        })(e) + 5;
        let r = !1;
        const a = ({ target: n })=>{
            n === e && (r = !0, e.removeEventListener(i, a), g(t));
        };
        e.addEventListener(i, a), setTimeout(()=>{
            r || s(e);
        }, o);
    }, b = (t, e, i, n)=>{
        const s = t.length;
        let o = t.indexOf(e);
        return -1 === o ? !i && n ? t[s - 1] : t[0] : (o += i ? 1 : -1, n && (o = (o + s) % s), t[Math.max(0, Math.min(o, s - 1))]);
    }, v = /[^.]*(?=\..*)\.|.*/, y = /\..*/, w = /::\d+$/, A = {};
    let E = 1;
    const T = {
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, C = new Set([
        "click",
        "dblclick",
        "mouseup",
        "mousedown",
        "contextmenu",
        "mousewheel",
        "DOMMouseScroll",
        "mouseover",
        "mouseout",
        "mousemove",
        "selectstart",
        "selectend",
        "keydown",
        "keypress",
        "keyup",
        "orientationchange",
        "touchstart",
        "touchmove",
        "touchend",
        "touchcancel",
        "pointerdown",
        "pointermove",
        "pointerup",
        "pointerleave",
        "pointercancel",
        "gesturestart",
        "gesturechange",
        "gestureend",
        "focus",
        "blur",
        "change",
        "reset",
        "select",
        "submit",
        "focusin",
        "focusout",
        "load",
        "unload",
        "beforeunload",
        "resize",
        "move",
        "DOMContentLoaded",
        "readystatechange",
        "error",
        "abort",
        "scroll"
    ]);
    function O(t, e) {
        return e && `${e}::${E++}` || t.uidEvent || E++;
    }
    function x(t) {
        const e = O(t);
        return t.uidEvent = e, A[e] = A[e] || {}, A[e];
    }
    function k(t, e, i = null) {
        return Object.values(t).find((t)=>t.callable === e && t.delegationSelector === i);
    }
    function L(t, e, i) {
        const n = "string" == typeof e, s = n ? i : e || i;
        let o = I(t);
        return C.has(o) || (o = t), [
            n,
            s,
            o
        ];
    }
    function S(t, e, i, n, s) {
        if ("string" != typeof e || !t) return;
        let [o, r, a] = L(e, i, n);
        if (e in T) {
            const t = (t)=>function(e) {
                    if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e);
                };
            r = t(r);
        }
        const l = x(t), c = l[a] || (l[a] = {}), h = k(c, r, o ? i : null);
        if (h) return void (h.oneOff = h.oneOff && s);
        const d = O(r, e.replace(v, "")), u = o ? function(t, e, i) {
            return function n(s) {
                const o = t.querySelectorAll(e);
                for(let { target: r } = s; r && r !== this; r = r.parentNode)for (const a of o)if (a === r) return P(s, {
                    delegateTarget: r
                }), n.oneOff && N.off(t, s.type, e, i), i.apply(r, [
                    s
                ]);
            };
        }(t, i, r) : function(t, e) {
            return function i(n) {
                return P(n, {
                    delegateTarget: t
                }), i.oneOff && N.off(t, n.type, e), e.apply(t, [
                    n
                ]);
            };
        }(t, r);
        u.delegationSelector = o ? i : null, u.callable = r, u.oneOff = s, u.uidEvent = d, c[d] = u, t.addEventListener(a, u, o);
    }
    function D(t, e, i, n, s) {
        const o = k(e[i], n, s);
        o && (t.removeEventListener(i, o, Boolean(s)), delete e[i][o.uidEvent]);
    }
    function $(t, e, i, n) {
        const s = e[i] || {};
        for (const [o, r] of Object.entries(s))o.includes(n) && D(t, e, i, r.callable, r.delegationSelector);
    }
    function I(t) {
        return t = t.replace(y, ""), T[t] || t;
    }
    const N = {
        on (t, e, i, n) {
            S(t, e, i, n, !1);
        },
        one (t, e, i, n) {
            S(t, e, i, n, !0);
        },
        off (t, e, i, n) {
            if ("string" != typeof e || !t) return;
            const [s, o, r] = L(e, i, n), a = r !== e, l = x(t), c = l[r] || {}, h = e.startsWith(".");
            if (void 0 === o) {
                if (h) for (const i of Object.keys(l))$(t, l, i, e.slice(1));
                for (const [i, n] of Object.entries(c)){
                    const s = i.replace(w, "");
                    a && !e.includes(s) || D(t, l, r, n.callable, n.delegationSelector);
                }
            } else {
                if (!Object.keys(c).length) return;
                D(t, l, r, o, s ? i : null);
            }
        },
        trigger (t, e, i) {
            if ("string" != typeof e || !t) return null;
            const n = u();
            let s = null, o = !0, r = !0, a = !1;
            e !== I(e) && n && (s = n.Event(e, i), n(t).trigger(s), o = !s.isPropagationStopped(), r = !s.isImmediatePropagationStopped(), a = s.isDefaultPrevented());
            const l = P(new Event(e, {
                bubbles: o,
                cancelable: !0
            }), i);
            return a && l.preventDefault(), r && t.dispatchEvent(l), l.defaultPrevented && s && s.preventDefault(), l;
        }
    };
    function P(t, e = {}) {
        for (const [i, n] of Object.entries(e))try {
            t[i] = n;
        } catch (e) {
            Object.defineProperty(t, i, {
                configurable: !0,
                get: ()=>n
            });
        }
        return t;
    }
    function j(t) {
        if ("true" === t) return !0;
        if ("false" === t) return !1;
        if (t === Number(t).toString()) return Number(t);
        if ("" === t || "null" === t) return null;
        if ("string" != typeof t) return t;
        try {
            return JSON.parse(decodeURIComponent(t));
        } catch (e) {
            return t;
        }
    }
    function M(t) {
        return t.replace(/[A-Z]/g, (t)=>`-${t.toLowerCase()}`);
    }
    const F = {
        setDataAttribute (t, e, i) {
            t.setAttribute(`data-bs-${M(e)}`, i);
        },
        removeDataAttribute (t, e) {
            t.removeAttribute(`data-bs-${M(e)}`);
        },
        getDataAttributes (t) {
            if (!t) return {};
            const e = {}, i = Object.keys(t.dataset).filter((t)=>t.startsWith("bs") && !t.startsWith("bsConfig"));
            for (const n of i){
                let i = n.replace(/^bs/, "");
                i = i.charAt(0).toLowerCase() + i.slice(1), e[i] = j(t.dataset[n]);
            }
            return e;
        },
        getDataAttribute: (t, e)=>j(t.getAttribute(`data-bs-${M(e)}`))
    };
    class H {
        static get Default() {
            return {};
        }
        static get DefaultType() {
            return {};
        }
        static get NAME() {
            throw new Error('You have to implement the static method "NAME", for each component!');
        }
        _getConfig(t) {
            return t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t;
        }
        _configAfterMerge(t) {
            return t;
        }
        _mergeConfigObj(t, e) {
            const i = o(e) ? F.getDataAttribute(e, "config") : {};
            return {
                ...this.constructor.Default,
                ..."object" == typeof i ? i : {},
                ...o(e) ? F.getDataAttributes(e) : {},
                ..."object" == typeof t ? t : {}
            };
        }
        _typeCheckConfig(t, e = this.constructor.DefaultType) {
            for (const [n, s] of Object.entries(e)){
                const e = t[n], r = o(e) ? "element" : null == (i = e) ? `${i}` : Object.prototype.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase();
                if (!new RegExp(s).test(r)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${n}" provided type "${r}" but expected type "${s}".`);
            }
            var i;
        }
    }
    class W extends H {
        constructor(t, i){
            super(), (t = r(t)) && (this._element = t, this._config = this._getConfig(i), e.set(this._element, this.constructor.DATA_KEY, this));
        }
        dispose() {
            e.remove(this._element, this.constructor.DATA_KEY), N.off(this._element, this.constructor.EVENT_KEY);
            for (const t of Object.getOwnPropertyNames(this))this[t] = null;
        }
        _queueCallback(t, e, i = !0) {
            _(t, e, i);
        }
        _getConfig(t) {
            return t = this._mergeConfigObj(t, this._element), t = this._configAfterMerge(t), this._typeCheckConfig(t), t;
        }
        static getInstance(t) {
            return e.get(r(t), this.DATA_KEY);
        }
        static getOrCreateInstance(t, e = {}) {
            return this.getInstance(t) || new this(t, "object" == typeof e ? e : null);
        }
        static get VERSION() {
            return "5.3.5";
        }
        static get DATA_KEY() {
            return `bs.${this.NAME}`;
        }
        static get EVENT_KEY() {
            return `.${this.DATA_KEY}`;
        }
        static eventName(t) {
            return `${t}${this.EVENT_KEY}`;
        }
    }
    const B = (t)=>{
        let e = t.getAttribute("data-bs-target");
        if (!e || "#" === e) {
            let i = t.getAttribute("href");
            if (!i || !i.includes("#") && !i.startsWith(".")) return null;
            i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`), e = i && "#" !== i ? i.trim() : null;
        }
        return e ? e.split(",").map((t)=>n(t)).join(",") : null;
    }, z = {
        find: (t, e = document.documentElement)=>[].concat(...Element.prototype.querySelectorAll.call(e, t)),
        findOne: (t, e = document.documentElement)=>Element.prototype.querySelector.call(e, t),
        children: (t, e)=>[].concat(...t.children).filter((t)=>t.matches(e)),
        parents (t, e) {
            const i = [];
            let n = t.parentNode.closest(e);
            for(; n;)i.push(n), n = n.parentNode.closest(e);
            return i;
        },
        prev (t, e) {
            let i = t.previousElementSibling;
            for(; i;){
                if (i.matches(e)) return [
                    i
                ];
                i = i.previousElementSibling;
            }
            return [];
        },
        next (t, e) {
            let i = t.nextElementSibling;
            for(; i;){
                if (i.matches(e)) return [
                    i
                ];
                i = i.nextElementSibling;
            }
            return [];
        },
        focusableChildren (t) {
            const e = [
                "a",
                "button",
                "input",
                "textarea",
                "select",
                "details",
                "[tabindex]",
                '[contenteditable="true"]'
            ].map((t)=>`${t}:not([tabindex^="-"])`).join(",");
            return this.find(e, t).filter((t)=>!l(t) && a(t));
        },
        getSelectorFromElement (t) {
            const e = B(t);
            return e && z.findOne(e) ? e : null;
        },
        getElementFromSelector (t) {
            const e = B(t);
            return e ? z.findOne(e) : null;
        },
        getMultipleElementsFromSelector (t) {
            const e = B(t);
            return e ? z.find(e) : [];
        }
    }, R = (t, e = "hide")=>{
        const i = `click.dismiss${t.EVENT_KEY}`, n = t.NAME;
        N.on(document, i, `[data-bs-dismiss="${n}"]`, function(i) {
            if ([
                "A",
                "AREA"
            ].includes(this.tagName) && i.preventDefault(), l(this)) return;
            const s = z.getElementFromSelector(this) || this.closest(`.${n}`);
            t.getOrCreateInstance(s)[e]();
        });
    }, q = ".bs.alert", V = `close${q}`, K = `closed${q}`;
    class Q extends W {
        static get NAME() {
            return "alert";
        }
        close() {
            if (N.trigger(this._element, V).defaultPrevented) return;
            this._element.classList.remove("show");
            const t = this._element.classList.contains("fade");
            this._queueCallback(()=>this._destroyElement(), this._element, t);
        }
        _destroyElement() {
            this._element.remove(), N.trigger(this._element, K), this.dispose();
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = Q.getOrCreateInstance(this);
                if ("string" == typeof t) {
                    if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                    e[t](this);
                }
            });
        }
    }
    R(Q, "close"), m(Q);
    const X = '[data-bs-toggle="button"]';
    class Y extends W {
        static get NAME() {
            return "button";
        }
        toggle() {
            this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"));
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = Y.getOrCreateInstance(this);
                "toggle" === t && e[t]();
            });
        }
    }
    N.on(document, "click.bs.button.data-api", X, (t)=>{
        t.preventDefault();
        const e = t.target.closest(X);
        Y.getOrCreateInstance(e).toggle();
    }), m(Y);
    const U = ".bs.swipe", G = `touchstart${U}`, J = `touchmove${U}`, Z = `touchend${U}`, tt = `pointerdown${U}`, et = `pointerup${U}`, it = {
        endCallback: null,
        leftCallback: null,
        rightCallback: null
    }, nt = {
        endCallback: "(function|null)",
        leftCallback: "(function|null)",
        rightCallback: "(function|null)"
    };
    class st extends H {
        constructor(t, e){
            super(), this._element = t, t && st.isSupported() && (this._config = this._getConfig(e), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents());
        }
        static get Default() {
            return it;
        }
        static get DefaultType() {
            return nt;
        }
        static get NAME() {
            return "swipe";
        }
        dispose() {
            N.off(this._element, U);
        }
        _start(t) {
            this._supportPointerEvents ? this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX) : this._deltaX = t.touches[0].clientX;
        }
        _end(t) {
            this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), g(this._config.endCallback);
        }
        _move(t) {
            this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX;
        }
        _handleSwipe() {
            const t = Math.abs(this._deltaX);
            if (t <= 40) return;
            const e = t / this._deltaX;
            this._deltaX = 0, e && g(e > 0 ? this._config.rightCallback : this._config.leftCallback);
        }
        _initEvents() {
            this._supportPointerEvents ? (N.on(this._element, tt, (t)=>this._start(t)), N.on(this._element, et, (t)=>this._end(t)), this._element.classList.add("pointer-event")) : (N.on(this._element, G, (t)=>this._start(t)), N.on(this._element, J, (t)=>this._move(t)), N.on(this._element, Z, (t)=>this._end(t)));
        }
        _eventIsPointerPenTouch(t) {
            return this._supportPointerEvents && ("pen" === t.pointerType || "touch" === t.pointerType);
        }
        static isSupported() {
            return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
        }
    }
    const ot = ".bs.carousel", rt = ".data-api", at = "ArrowLeft", lt = "ArrowRight", ct = "next", ht = "prev", dt = "left", ut = "right", ft = `slide${ot}`, pt = `slid${ot}`, mt = `keydown${ot}`, gt = `mouseenter${ot}`, _t = `mouseleave${ot}`, bt = `dragstart${ot}`, vt = `load${ot}${rt}`, yt = `click${ot}${rt}`, wt = "carousel", At = "active", Et = ".active", Tt = ".carousel-item", Ct = Et + Tt, Ot = {
        [at]: ut,
        [lt]: dt
    }, xt = {
        interval: 5e3,
        keyboard: !0,
        pause: "hover",
        ride: !1,
        touch: !0,
        wrap: !0
    }, kt = {
        interval: "(number|boolean)",
        keyboard: "boolean",
        pause: "(string|boolean)",
        ride: "(boolean|string)",
        touch: "boolean",
        wrap: "boolean"
    };
    class Lt extends W {
        constructor(t, e){
            super(t, e), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = z.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === wt && this.cycle();
        }
        static get Default() {
            return xt;
        }
        static get DefaultType() {
            return kt;
        }
        static get NAME() {
            return "carousel";
        }
        next() {
            this._slide(ct);
        }
        nextWhenVisible() {
            !document.hidden && a(this._element) && this.next();
        }
        prev() {
            this._slide(ht);
        }
        pause() {
            this._isSliding && s(this._element), this._clearInterval();
        }
        cycle() {
            this._clearInterval(), this._updateInterval(), this._interval = setInterval(()=>this.nextWhenVisible(), this._config.interval);
        }
        _maybeEnableCycle() {
            this._config.ride && (this._isSliding ? N.one(this._element, pt, ()=>this.cycle()) : this.cycle());
        }
        to(t) {
            const e = this._getItems();
            if (t > e.length - 1 || t < 0) return;
            if (this._isSliding) return void N.one(this._element, pt, ()=>this.to(t));
            const i = this._getItemIndex(this._getActive());
            if (i === t) return;
            const n = t > i ? ct : ht;
            this._slide(n, e[t]);
        }
        dispose() {
            this._swipeHelper && this._swipeHelper.dispose(), super.dispose();
        }
        _configAfterMerge(t) {
            return t.defaultInterval = t.interval, t;
        }
        _addEventListeners() {
            this._config.keyboard && N.on(this._element, mt, (t)=>this._keydown(t)), "hover" === this._config.pause && (N.on(this._element, gt, ()=>this.pause()), N.on(this._element, _t, ()=>this._maybeEnableCycle())), this._config.touch && st.isSupported() && this._addTouchEventListeners();
        }
        _addTouchEventListeners() {
            for (const t of z.find(".carousel-item img", this._element))N.on(t, bt, (t)=>t.preventDefault());
            const t = {
                leftCallback: ()=>this._slide(this._directionToOrder(dt)),
                rightCallback: ()=>this._slide(this._directionToOrder(ut)),
                endCallback: ()=>{
                    "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(()=>this._maybeEnableCycle(), 500 + this._config.interval));
                }
            };
            this._swipeHelper = new st(this._element, t);
        }
        _keydown(t) {
            if (/input|textarea/i.test(t.target.tagName)) return;
            const e = Ot[t.key];
            e && (t.preventDefault(), this._slide(this._directionToOrder(e)));
        }
        _getItemIndex(t) {
            return this._getItems().indexOf(t);
        }
        _setActiveIndicatorElement(t) {
            if (!this._indicatorsElement) return;
            const e = z.findOne(Et, this._indicatorsElement);
            e.classList.remove(At), e.removeAttribute("aria-current");
            const i = z.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement);
            i && (i.classList.add(At), i.setAttribute("aria-current", "true"));
        }
        _updateInterval() {
            const t = this._activeElement || this._getActive();
            if (!t) return;
            const e = Number.parseInt(t.getAttribute("data-bs-interval"), 10);
            this._config.interval = e || this._config.defaultInterval;
        }
        _slide(t, e = null) {
            if (this._isSliding) return;
            const i = this._getActive(), n = t === ct, s = e || b(this._getItems(), i, n, this._config.wrap);
            if (s === i) return;
            const o = this._getItemIndex(s), r = (e)=>N.trigger(this._element, e, {
                    relatedTarget: s,
                    direction: this._orderToDirection(t),
                    from: this._getItemIndex(i),
                    to: o
                });
            if (r(ft).defaultPrevented) return;
            if (!i || !s) return;
            const a = Boolean(this._interval);
            this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o), this._activeElement = s;
            const l = n ? "carousel-item-start" : "carousel-item-end", c = n ? "carousel-item-next" : "carousel-item-prev";
            s.classList.add(c), d(s), i.classList.add(l), s.classList.add(l), this._queueCallback(()=>{
                s.classList.remove(l, c), s.classList.add(At), i.classList.remove(At, c, l), this._isSliding = !1, r(pt);
            }, i, this._isAnimated()), a && this.cycle();
        }
        _isAnimated() {
            return this._element.classList.contains("slide");
        }
        _getActive() {
            return z.findOne(Ct, this._element);
        }
        _getItems() {
            return z.find(Tt, this._element);
        }
        _clearInterval() {
            this._interval && (clearInterval(this._interval), this._interval = null);
        }
        _directionToOrder(t) {
            return p() ? t === dt ? ht : ct : t === dt ? ct : ht;
        }
        _orderToDirection(t) {
            return p() ? t === ht ? dt : ut : t === ht ? ut : dt;
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = Lt.getOrCreateInstance(this, t);
                if ("number" != typeof t) {
                    if ("string" == typeof t) {
                        if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                        e[t]();
                    }
                } else e.to(t);
            });
        }
    }
    N.on(document, yt, "[data-bs-slide], [data-bs-slide-to]", function(t) {
        const e = z.getElementFromSelector(this);
        if (!e || !e.classList.contains(wt)) return;
        t.preventDefault();
        const i = Lt.getOrCreateInstance(e), n = this.getAttribute("data-bs-slide-to");
        return n ? (i.to(n), void i._maybeEnableCycle()) : "next" === F.getDataAttribute(this, "slide") ? (i.next(), void i._maybeEnableCycle()) : (i.prev(), void i._maybeEnableCycle());
    }), N.on(window, vt, ()=>{
        const t = z.find('[data-bs-ride="carousel"]');
        for (const e of t)Lt.getOrCreateInstance(e);
    }), m(Lt);
    const St = ".bs.collapse", Dt = `show${St}`, $t = `shown${St}`, It = `hide${St}`, Nt = `hidden${St}`, Pt = `click${St}.data-api`, jt = "show", Mt = "collapse", Ft = "collapsing", Ht = `:scope .${Mt} .${Mt}`, Wt = '[data-bs-toggle="collapse"]', Bt = {
        parent: null,
        toggle: !0
    }, zt = {
        parent: "(null|element)",
        toggle: "boolean"
    };
    class Rt extends W {
        constructor(t, e){
            super(t, e), this._isTransitioning = !1, this._triggerArray = [];
            const i = z.find(Wt);
            for (const t of i){
                const e = z.getSelectorFromElement(t), i = z.find(e).filter((t)=>t === this._element);
                null !== e && i.length && this._triggerArray.push(t);
            }
            this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
        }
        static get Default() {
            return Bt;
        }
        static get DefaultType() {
            return zt;
        }
        static get NAME() {
            return "collapse";
        }
        toggle() {
            this._isShown() ? this.hide() : this.show();
        }
        show() {
            if (this._isTransitioning || this._isShown()) return;
            let t = [];
            if (this._config.parent && (t = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((t)=>t !== this._element).map((t)=>Rt.getOrCreateInstance(t, {
                    toggle: !1
                }))), t.length && t[0]._isTransitioning) return;
            if (N.trigger(this._element, Dt).defaultPrevented) return;
            for (const e of t)e.hide();
            const e = this._getDimension();
            this._element.classList.remove(Mt), this._element.classList.add(Ft), this._element.style[e] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
            const i = `scroll${e[0].toUpperCase() + e.slice(1)}`;
            this._queueCallback(()=>{
                this._isTransitioning = !1, this._element.classList.remove(Ft), this._element.classList.add(Mt, jt), this._element.style[e] = "", N.trigger(this._element, $t);
            }, this._element, !0), this._element.style[e] = `${this._element[i]}px`;
        }
        hide() {
            if (this._isTransitioning || !this._isShown()) return;
            if (N.trigger(this._element, It).defaultPrevented) return;
            const t = this._getDimension();
            this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`, d(this._element), this._element.classList.add(Ft), this._element.classList.remove(Mt, jt);
            for (const t of this._triggerArray){
                const e = z.getElementFromSelector(t);
                e && !this._isShown(e) && this._addAriaAndCollapsedClass([
                    t
                ], !1);
            }
            this._isTransitioning = !0, this._element.style[t] = "", this._queueCallback(()=>{
                this._isTransitioning = !1, this._element.classList.remove(Ft), this._element.classList.add(Mt), N.trigger(this._element, Nt);
            }, this._element, !0);
        }
        _isShown(t = this._element) {
            return t.classList.contains(jt);
        }
        _configAfterMerge(t) {
            return t.toggle = Boolean(t.toggle), t.parent = r(t.parent), t;
        }
        _getDimension() {
            return this._element.classList.contains("collapse-horizontal") ? "width" : "height";
        }
        _initializeChildren() {
            if (!this._config.parent) return;
            const t = this._getFirstLevelChildren(Wt);
            for (const e of t){
                const t = z.getElementFromSelector(e);
                t && this._addAriaAndCollapsedClass([
                    e
                ], this._isShown(t));
            }
        }
        _getFirstLevelChildren(t) {
            const e = z.find(Ht, this._config.parent);
            return z.find(t, this._config.parent).filter((t)=>!e.includes(t));
        }
        _addAriaAndCollapsedClass(t, e) {
            if (t.length) for (const i of t)i.classList.toggle("collapsed", !e), i.setAttribute("aria-expanded", e);
        }
        static jQueryInterface(t) {
            const e = {};
            return "string" == typeof t && /show|hide/.test(t) && (e.toggle = !1), this.each(function() {
                const i = Rt.getOrCreateInstance(this, e);
                if ("string" == typeof t) {
                    if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
                    i[t]();
                }
            });
        }
    }
    N.on(document, Pt, Wt, function(t) {
        ("A" === t.target.tagName || t.delegateTarget && "A" === t.delegateTarget.tagName) && t.preventDefault();
        for (const t of z.getMultipleElementsFromSelector(this))Rt.getOrCreateInstance(t, {
            toggle: !1
        }).toggle();
    }), m(Rt);
    var qt = "top", Vt = "bottom", Kt = "right", Qt = "left", Xt = "auto", Yt = [
        qt,
        Vt,
        Kt,
        Qt
    ], Ut = "start", Gt = "end", Jt = "clippingParents", Zt = "viewport", te = "popper", ee = "reference", ie = Yt.reduce(function(t, e) {
        return t.concat([
            e + "-" + Ut,
            e + "-" + Gt
        ]);
    }, []), ne = [].concat(Yt, [
        Xt
    ]).reduce(function(t, e) {
        return t.concat([
            e,
            e + "-" + Ut,
            e + "-" + Gt
        ]);
    }, []), se = "beforeRead", oe = "read", re = "afterRead", ae = "beforeMain", le = "main", ce = "afterMain", he = "beforeWrite", de = "write", ue = "afterWrite", fe = [
        se,
        oe,
        re,
        ae,
        le,
        ce,
        he,
        de,
        ue
    ];
    function pe(t) {
        return t ? (t.nodeName || "").toLowerCase() : null;
    }
    function me(t) {
        if (null == t) return window;
        if ("[object Window]" !== t.toString()) {
            var e = t.ownerDocument;
            return e && e.defaultView || window;
        }
        return t;
    }
    function ge(t) {
        return t instanceof me(t).Element || t instanceof Element;
    }
    function _e(t) {
        return t instanceof me(t).HTMLElement || t instanceof HTMLElement;
    }
    function be(t) {
        return "undefined" != typeof ShadowRoot && (t instanceof me(t).ShadowRoot || t instanceof ShadowRoot);
    }
    const ve = {
        name: "applyStyles",
        enabled: !0,
        phase: "write",
        fn: function(t) {
            var e = t.state;
            Object.keys(e.elements).forEach(function(t) {
                var i = e.styles[t] || {}, n = e.attributes[t] || {}, s = e.elements[t];
                _e(s) && pe(s) && (Object.assign(s.style, i), Object.keys(n).forEach(function(t) {
                    var e = n[t];
                    !1 === e ? s.removeAttribute(t) : s.setAttribute(t, !0 === e ? "" : e);
                }));
            });
        },
        effect: function(t) {
            var e = t.state, i = {
                popper: {
                    position: e.options.strategy,
                    left: "0",
                    top: "0",
                    margin: "0"
                },
                arrow: {
                    position: "absolute"
                },
                reference: {}
            };
            return Object.assign(e.elements.popper.style, i.popper), e.styles = i, e.elements.arrow && Object.assign(e.elements.arrow.style, i.arrow), function() {
                Object.keys(e.elements).forEach(function(t) {
                    var n = e.elements[t], s = e.attributes[t] || {}, o = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : i[t]).reduce(function(t, e) {
                        return t[e] = "", t;
                    }, {});
                    _e(n) && pe(n) && (Object.assign(n.style, o), Object.keys(s).forEach(function(t) {
                        n.removeAttribute(t);
                    }));
                });
            };
        },
        requires: [
            "computeStyles"
        ]
    };
    function ye(t) {
        return t.split("-")[0];
    }
    var we = Math.max, Ae = Math.min, Ee = Math.round;
    function Te() {
        var t = navigator.userAgentData;
        return null != t && t.brands && Array.isArray(t.brands) ? t.brands.map(function(t) {
            return t.brand + "/" + t.version;
        }).join(" ") : navigator.userAgent;
    }
    function Ce() {
        return !/^((?!chrome|android).)*safari/i.test(Te());
    }
    function Oe(t, e, i) {
        void 0 === e && (e = !1), void 0 === i && (i = !1);
        var n = t.getBoundingClientRect(), s = 1, o = 1;
        e && _e(t) && (s = t.offsetWidth > 0 && Ee(n.width) / t.offsetWidth || 1, o = t.offsetHeight > 0 && Ee(n.height) / t.offsetHeight || 1);
        var r = (ge(t) ? me(t) : window).visualViewport, a = !Ce() && i, l = (n.left + (a && r ? r.offsetLeft : 0)) / s, c = (n.top + (a && r ? r.offsetTop : 0)) / o, h = n.width / s, d = n.height / o;
        return {
            width: h,
            height: d,
            top: c,
            right: l + h,
            bottom: c + d,
            left: l,
            x: l,
            y: c
        };
    }
    function xe(t) {
        var e = Oe(t), i = t.offsetWidth, n = t.offsetHeight;
        return Math.abs(e.width - i) <= 1 && (i = e.width), Math.abs(e.height - n) <= 1 && (n = e.height), {
            x: t.offsetLeft,
            y: t.offsetTop,
            width: i,
            height: n
        };
    }
    function ke(t, e) {
        var i = e.getRootNode && e.getRootNode();
        if (t.contains(e)) return !0;
        if (i && be(i)) {
            var n = e;
            do {
                if (n && t.isSameNode(n)) return !0;
                n = n.parentNode || n.host;
            }while (n)
        }
        return !1;
    }
    function Le(t) {
        return me(t).getComputedStyle(t);
    }
    function Se(t) {
        return [
            "table",
            "td",
            "th"
        ].indexOf(pe(t)) >= 0;
    }
    function De(t) {
        return ((ge(t) ? t.ownerDocument : t.document) || window.document).documentElement;
    }
    function $e(t) {
        return "html" === pe(t) ? t : t.assignedSlot || t.parentNode || (be(t) ? t.host : null) || De(t);
    }
    function Ie(t) {
        return _e(t) && "fixed" !== Le(t).position ? t.offsetParent : null;
    }
    function Ne(t) {
        for(var e = me(t), i = Ie(t); i && Se(i) && "static" === Le(i).position;)i = Ie(i);
        return i && ("html" === pe(i) || "body" === pe(i) && "static" === Le(i).position) ? e : i || function(t) {
            var e = /firefox/i.test(Te());
            if (/Trident/i.test(Te()) && _e(t) && "fixed" === Le(t).position) return null;
            var i = $e(t);
            for(be(i) && (i = i.host); _e(i) && [
                "html",
                "body"
            ].indexOf(pe(i)) < 0;){
                var n = Le(i);
                if ("none" !== n.transform || "none" !== n.perspective || "paint" === n.contain || -1 !== [
                    "transform",
                    "perspective"
                ].indexOf(n.willChange) || e && "filter" === n.willChange || e && n.filter && "none" !== n.filter) return i;
                i = i.parentNode;
            }
            return null;
        }(t) || e;
    }
    function Pe(t) {
        return [
            "top",
            "bottom"
        ].indexOf(t) >= 0 ? "x" : "y";
    }
    function je(t, e, i) {
        return we(t, Ae(e, i));
    }
    function Me(t) {
        return Object.assign({}, {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, t);
    }
    function Fe(t, e) {
        return e.reduce(function(e, i) {
            return e[i] = t, e;
        }, {});
    }
    const He = {
        name: "arrow",
        enabled: !0,
        phase: "main",
        fn: function(t) {
            var e, i = t.state, n = t.name, s = t.options, o = i.elements.arrow, r = i.modifiersData.popperOffsets, a = ye(i.placement), l = Pe(a), c = [
                Qt,
                Kt
            ].indexOf(a) >= 0 ? "height" : "width";
            if (o && r) {
                var h = function(t, e) {
                    return Me("number" != typeof (t = "function" == typeof t ? t(Object.assign({}, e.rects, {
                        placement: e.placement
                    })) : t) ? t : Fe(t, Yt));
                }(s.padding, i), d = xe(o), u = "y" === l ? qt : Qt, f = "y" === l ? Vt : Kt, p = i.rects.reference[c] + i.rects.reference[l] - r[l] - i.rects.popper[c], m = r[l] - i.rects.reference[l], g = Ne(o), _ = g ? "y" === l ? g.clientHeight || 0 : g.clientWidth || 0 : 0, b = p / 2 - m / 2, v = h[u], y = _ - d[c] - h[f], w = _ / 2 - d[c] / 2 + b, A = je(v, w, y), E = l;
                i.modifiersData[n] = ((e = {})[E] = A, e.centerOffset = A - w, e);
            }
        },
        effect: function(t) {
            var e = t.state, i = t.options.element, n = void 0 === i ? "[data-popper-arrow]" : i;
            null != n && ("string" != typeof n || (n = e.elements.popper.querySelector(n))) && ke(e.elements.popper, n) && (e.elements.arrow = n);
        },
        requires: [
            "popperOffsets"
        ],
        requiresIfExists: [
            "preventOverflow"
        ]
    };
    function We(t) {
        return t.split("-")[1];
    }
    var Be = {
        top: "auto",
        right: "auto",
        bottom: "auto",
        left: "auto"
    };
    function ze(t) {
        var e, i = t.popper, n = t.popperRect, s = t.placement, o = t.variation, r = t.offsets, a = t.position, l = t.gpuAcceleration, c = t.adaptive, h = t.roundOffsets, d = t.isFixed, u = r.x, f = void 0 === u ? 0 : u, p = r.y, m = void 0 === p ? 0 : p, g = "function" == typeof h ? h({
            x: f,
            y: m
        }) : {
            x: f,
            y: m
        };
        f = g.x, m = g.y;
        var _ = r.hasOwnProperty("x"), b = r.hasOwnProperty("y"), v = Qt, y = qt, w = window;
        if (c) {
            var A = Ne(i), E = "clientHeight", T = "clientWidth";
            A === me(i) && "static" !== Le(A = De(i)).position && "absolute" === a && (E = "scrollHeight", T = "scrollWidth"), (s === qt || (s === Qt || s === Kt) && o === Gt) && (y = Vt, m -= (d && A === w && w.visualViewport ? w.visualViewport.height : A[E]) - n.height, m *= l ? 1 : -1), s !== Qt && (s !== qt && s !== Vt || o !== Gt) || (v = Kt, f -= (d && A === w && w.visualViewport ? w.visualViewport.width : A[T]) - n.width, f *= l ? 1 : -1);
        }
        var C, O = Object.assign({
            position: a
        }, c && Be), x = !0 === h ? function(t, e) {
            var i = t.x, n = t.y, s = e.devicePixelRatio || 1;
            return {
                x: Ee(i * s) / s || 0,
                y: Ee(n * s) / s || 0
            };
        }({
            x: f,
            y: m
        }, me(i)) : {
            x: f,
            y: m
        };
        return f = x.x, m = x.y, l ? Object.assign({}, O, ((C = {})[y] = b ? "0" : "", C[v] = _ ? "0" : "", C.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + m + "px)" : "translate3d(" + f + "px, " + m + "px, 0)", C)) : Object.assign({}, O, ((e = {})[y] = b ? m + "px" : "", e[v] = _ ? f + "px" : "", e.transform = "", e));
    }
    const Re = {
        name: "computeStyles",
        enabled: !0,
        phase: "beforeWrite",
        fn: function(t) {
            var e = t.state, i = t.options, n = i.gpuAcceleration, s = void 0 === n || n, o = i.adaptive, r = void 0 === o || o, a = i.roundOffsets, l = void 0 === a || a, c = {
                placement: ye(e.placement),
                variation: We(e.placement),
                popper: e.elements.popper,
                popperRect: e.rects.popper,
                gpuAcceleration: s,
                isFixed: "fixed" === e.options.strategy
            };
            null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign({}, e.styles.popper, ze(Object.assign({}, c, {
                offsets: e.modifiersData.popperOffsets,
                position: e.options.strategy,
                adaptive: r,
                roundOffsets: l
            })))), null != e.modifiersData.arrow && (e.styles.arrow = Object.assign({}, e.styles.arrow, ze(Object.assign({}, c, {
                offsets: e.modifiersData.arrow,
                position: "absolute",
                adaptive: !1,
                roundOffsets: l
            })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
                "data-popper-placement": e.placement
            });
        },
        data: {}
    };
    var qe = {
        passive: !0
    };
    const Ve = {
        name: "eventListeners",
        enabled: !0,
        phase: "write",
        fn: function() {},
        effect: function(t) {
            var e = t.state, i = t.instance, n = t.options, s = n.scroll, o = void 0 === s || s, r = n.resize, a = void 0 === r || r, l = me(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
            return o && c.forEach(function(t) {
                t.addEventListener("scroll", i.update, qe);
            }), a && l.addEventListener("resize", i.update, qe), function() {
                o && c.forEach(function(t) {
                    t.removeEventListener("scroll", i.update, qe);
                }), a && l.removeEventListener("resize", i.update, qe);
            };
        },
        data: {}
    };
    var Ke = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
    };
    function Qe(t) {
        return t.replace(/left|right|bottom|top/g, function(t) {
            return Ke[t];
        });
    }
    var Xe = {
        start: "end",
        end: "start"
    };
    function Ye(t) {
        return t.replace(/start|end/g, function(t) {
            return Xe[t];
        });
    }
    function Ue(t) {
        var e = me(t);
        return {
            scrollLeft: e.pageXOffset,
            scrollTop: e.pageYOffset
        };
    }
    function Ge(t) {
        return Oe(De(t)).left + Ue(t).scrollLeft;
    }
    function Je(t) {
        var e = Le(t), i = e.overflow, n = e.overflowX, s = e.overflowY;
        return /auto|scroll|overlay|hidden/.test(i + s + n);
    }
    function Ze(t) {
        return [
            "html",
            "body",
            "#document"
        ].indexOf(pe(t)) >= 0 ? t.ownerDocument.body : _e(t) && Je(t) ? t : Ze($e(t));
    }
    function ti(t, e) {
        var i;
        void 0 === e && (e = []);
        var n = Ze(t), s = n === (null == (i = t.ownerDocument) ? void 0 : i.body), o = me(n), r = s ? [
            o
        ].concat(o.visualViewport || [], Je(n) ? n : []) : n, a = e.concat(r);
        return s ? a : a.concat(ti($e(r)));
    }
    function ei(t) {
        return Object.assign({}, t, {
            left: t.x,
            top: t.y,
            right: t.x + t.width,
            bottom: t.y + t.height
        });
    }
    function ii(t, e, i) {
        return e === Zt ? ei(function(t, e) {
            var i = me(t), n = De(t), s = i.visualViewport, o = n.clientWidth, r = n.clientHeight, a = 0, l = 0;
            if (s) {
                o = s.width, r = s.height;
                var c = Ce();
                (c || !c && "fixed" === e) && (a = s.offsetLeft, l = s.offsetTop);
            }
            return {
                width: o,
                height: r,
                x: a + Ge(t),
                y: l
            };
        }(t, i)) : ge(e) ? function(t, e) {
            var i = Oe(t, !1, "fixed" === e);
            return i.top = i.top + t.clientTop, i.left = i.left + t.clientLeft, i.bottom = i.top + t.clientHeight, i.right = i.left + t.clientWidth, i.width = t.clientWidth, i.height = t.clientHeight, i.x = i.left, i.y = i.top, i;
        }(e, i) : ei(function(t) {
            var e, i = De(t), n = Ue(t), s = null == (e = t.ownerDocument) ? void 0 : e.body, o = we(i.scrollWidth, i.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0), r = we(i.scrollHeight, i.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0), a = -n.scrollLeft + Ge(t), l = -n.scrollTop;
            return "rtl" === Le(s || i).direction && (a += we(i.clientWidth, s ? s.clientWidth : 0) - o), {
                width: o,
                height: r,
                x: a,
                y: l
            };
        }(De(t)));
    }
    function ni(t) {
        var e, i = t.reference, n = t.element, s = t.placement, o = s ? ye(s) : null, r = s ? We(s) : null, a = i.x + i.width / 2 - n.width / 2, l = i.y + i.height / 2 - n.height / 2;
        switch(o){
            case qt:
                e = {
                    x: a,
                    y: i.y - n.height
                };
                break;
            case Vt:
                e = {
                    x: a,
                    y: i.y + i.height
                };
                break;
            case Kt:
                e = {
                    x: i.x + i.width,
                    y: l
                };
                break;
            case Qt:
                e = {
                    x: i.x - n.width,
                    y: l
                };
                break;
            default:
                e = {
                    x: i.x,
                    y: i.y
                };
        }
        var c = o ? Pe(o) : null;
        if (null != c) {
            var h = "y" === c ? "height" : "width";
            switch(r){
                case Ut:
                    e[c] = e[c] - (i[h] / 2 - n[h] / 2);
                    break;
                case Gt:
                    e[c] = e[c] + (i[h] / 2 - n[h] / 2);
            }
        }
        return e;
    }
    function si(t, e) {
        void 0 === e && (e = {});
        var i = e, n = i.placement, s = void 0 === n ? t.placement : n, o = i.strategy, r = void 0 === o ? t.strategy : o, a = i.boundary, l = void 0 === a ? Jt : a, c = i.rootBoundary, h = void 0 === c ? Zt : c, d = i.elementContext, u = void 0 === d ? te : d, f = i.altBoundary, p = void 0 !== f && f, m = i.padding, g = void 0 === m ? 0 : m, _ = Me("number" != typeof g ? g : Fe(g, Yt)), b = u === te ? ee : te, v = t.rects.popper, y = t.elements[p ? b : u], w = function(t, e, i, n) {
            var s = "clippingParents" === e ? function(t) {
                var e = ti($e(t)), i = [
                    "absolute",
                    "fixed"
                ].indexOf(Le(t).position) >= 0 && _e(t) ? Ne(t) : t;
                return ge(i) ? e.filter(function(t) {
                    return ge(t) && ke(t, i) && "body" !== pe(t);
                }) : [];
            }(t) : [].concat(e), o = [].concat(s, [
                i
            ]), r = o[0], a = o.reduce(function(e, i) {
                var s = ii(t, i, n);
                return e.top = we(s.top, e.top), e.right = Ae(s.right, e.right), e.bottom = Ae(s.bottom, e.bottom), e.left = we(s.left, e.left), e;
            }, ii(t, r, n));
            return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
        }(ge(y) ? y : y.contextElement || De(t.elements.popper), l, h, r), A = Oe(t.elements.reference), E = ni({
            reference: A,
            element: v,
            placement: s
        }), T = ei(Object.assign({}, v, E)), C = u === te ? T : A, O = {
            top: w.top - C.top + _.top,
            bottom: C.bottom - w.bottom + _.bottom,
            left: w.left - C.left + _.left,
            right: C.right - w.right + _.right
        }, x = t.modifiersData.offset;
        if (u === te && x) {
            var k = x[s];
            Object.keys(O).forEach(function(t) {
                var e = [
                    Kt,
                    Vt
                ].indexOf(t) >= 0 ? 1 : -1, i = [
                    qt,
                    Vt
                ].indexOf(t) >= 0 ? "y" : "x";
                O[t] += k[i] * e;
            });
        }
        return O;
    }
    function oi(t, e) {
        void 0 === e && (e = {});
        var i = e, n = i.placement, s = i.boundary, o = i.rootBoundary, r = i.padding, a = i.flipVariations, l = i.allowedAutoPlacements, c = void 0 === l ? ne : l, h = We(n), d = h ? a ? ie : ie.filter(function(t) {
            return We(t) === h;
        }) : Yt, u = d.filter(function(t) {
            return c.indexOf(t) >= 0;
        });
        0 === u.length && (u = d);
        var f = u.reduce(function(e, i) {
            return e[i] = si(t, {
                placement: i,
                boundary: s,
                rootBoundary: o,
                padding: r
            })[ye(i)], e;
        }, {});
        return Object.keys(f).sort(function(t, e) {
            return f[t] - f[e];
        });
    }
    const ri = {
        name: "flip",
        enabled: !0,
        phase: "main",
        fn: function(t) {
            var e = t.state, i = t.options, n = t.name;
            if (!e.modifiersData[n]._skip) {
                for(var s = i.mainAxis, o = void 0 === s || s, r = i.altAxis, a = void 0 === r || r, l = i.fallbackPlacements, c = i.padding, h = i.boundary, d = i.rootBoundary, u = i.altBoundary, f = i.flipVariations, p = void 0 === f || f, m = i.allowedAutoPlacements, g = e.options.placement, _ = ye(g), b = l || (_ !== g && p ? function(t) {
                    if (ye(t) === Xt) return [];
                    var e = Qe(t);
                    return [
                        Ye(t),
                        e,
                        Ye(e)
                    ];
                }(g) : [
                    Qe(g)
                ]), v = [
                    g
                ].concat(b).reduce(function(t, i) {
                    return t.concat(ye(i) === Xt ? oi(e, {
                        placement: i,
                        boundary: h,
                        rootBoundary: d,
                        padding: c,
                        flipVariations: p,
                        allowedAutoPlacements: m
                    }) : i);
                }, []), y = e.rects.reference, w = e.rects.popper, A = new Map, E = !0, T = v[0], C = 0; C < v.length; C++){
                    var O = v[C], x = ye(O), k = We(O) === Ut, L = [
                        qt,
                        Vt
                    ].indexOf(x) >= 0, S = L ? "width" : "height", D = si(e, {
                        placement: O,
                        boundary: h,
                        rootBoundary: d,
                        altBoundary: u,
                        padding: c
                    }), $ = L ? k ? Kt : Qt : k ? Vt : qt;
                    y[S] > w[S] && ($ = Qe($));
                    var I = Qe($), N = [];
                    if (o && N.push(D[x] <= 0), a && N.push(D[$] <= 0, D[I] <= 0), N.every(function(t) {
                        return t;
                    })) {
                        T = O, E = !1;
                        break;
                    }
                    A.set(O, N);
                }
                if (E) for(var P = function(t) {
                    var e = v.find(function(e) {
                        var i = A.get(e);
                        if (i) return i.slice(0, t).every(function(t) {
                            return t;
                        });
                    });
                    if (e) return T = e, "break";
                }, j = p ? 3 : 1; j > 0 && "break" !== P(j); j--);
                e.placement !== T && (e.modifiersData[n]._skip = !0, e.placement = T, e.reset = !0);
            }
        },
        requiresIfExists: [
            "offset"
        ],
        data: {
            _skip: !1
        }
    };
    function ai(t, e, i) {
        return void 0 === i && (i = {
            x: 0,
            y: 0
        }), {
            top: t.top - e.height - i.y,
            right: t.right - e.width + i.x,
            bottom: t.bottom - e.height + i.y,
            left: t.left - e.width - i.x
        };
    }
    function li(t) {
        return [
            qt,
            Kt,
            Vt,
            Qt
        ].some(function(e) {
            return t[e] >= 0;
        });
    }
    const ci = {
        name: "hide",
        enabled: !0,
        phase: "main",
        requiresIfExists: [
            "preventOverflow"
        ],
        fn: function(t) {
            var e = t.state, i = t.name, n = e.rects.reference, s = e.rects.popper, o = e.modifiersData.preventOverflow, r = si(e, {
                elementContext: "reference"
            }), a = si(e, {
                altBoundary: !0
            }), l = ai(r, n), c = ai(a, s, o), h = li(l), d = li(c);
            e.modifiersData[i] = {
                referenceClippingOffsets: l,
                popperEscapeOffsets: c,
                isReferenceHidden: h,
                hasPopperEscaped: d
            }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
                "data-popper-reference-hidden": h,
                "data-popper-escaped": d
            });
        }
    }, hi = {
        name: "offset",
        enabled: !0,
        phase: "main",
        requires: [
            "popperOffsets"
        ],
        fn: function(t) {
            var e = t.state, i = t.options, n = t.name, s = i.offset, o = void 0 === s ? [
                0,
                0
            ] : s, r = ne.reduce(function(t, i) {
                return t[i] = function(t, e, i) {
                    var n = ye(t), s = [
                        Qt,
                        qt
                    ].indexOf(n) >= 0 ? -1 : 1, o = "function" == typeof i ? i(Object.assign({}, e, {
                        placement: t
                    })) : i, r = o[0], a = o[1];
                    return r = r || 0, a = (a || 0) * s, [
                        Qt,
                        Kt
                    ].indexOf(n) >= 0 ? {
                        x: a,
                        y: r
                    } : {
                        x: r,
                        y: a
                    };
                }(i, e.rects, o), t;
            }, {}), a = r[e.placement], l = a.x, c = a.y;
            null != e.modifiersData.popperOffsets && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[n] = r;
        }
    }, di = {
        name: "popperOffsets",
        enabled: !0,
        phase: "read",
        fn: function(t) {
            var e = t.state, i = t.name;
            e.modifiersData[i] = ni({
                reference: e.rects.reference,
                element: e.rects.popper,
                placement: e.placement
            });
        },
        data: {}
    }, ui = {
        name: "preventOverflow",
        enabled: !0,
        phase: "main",
        fn: function(t) {
            var e = t.state, i = t.options, n = t.name, s = i.mainAxis, o = void 0 === s || s, r = i.altAxis, a = void 0 !== r && r, l = i.boundary, c = i.rootBoundary, h = i.altBoundary, d = i.padding, u = i.tether, f = void 0 === u || u, p = i.tetherOffset, m = void 0 === p ? 0 : p, g = si(e, {
                boundary: l,
                rootBoundary: c,
                padding: d,
                altBoundary: h
            }), _ = ye(e.placement), b = We(e.placement), v = !b, y = Pe(_), w = "x" === y ? "y" : "x", A = e.modifiersData.popperOffsets, E = e.rects.reference, T = e.rects.popper, C = "function" == typeof m ? m(Object.assign({}, e.rects, {
                placement: e.placement
            })) : m, O = "number" == typeof C ? {
                mainAxis: C,
                altAxis: C
            } : Object.assign({
                mainAxis: 0,
                altAxis: 0
            }, C), x = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, k = {
                x: 0,
                y: 0
            };
            if (A) {
                if (o) {
                    var L, S = "y" === y ? qt : Qt, D = "y" === y ? Vt : Kt, $ = "y" === y ? "height" : "width", I = A[y], N = I + g[S], P = I - g[D], j = f ? -T[$] / 2 : 0, M = b === Ut ? E[$] : T[$], F = b === Ut ? -T[$] : -E[$], H = e.elements.arrow, W = f && H ? xe(H) : {
                        width: 0,
                        height: 0
                    }, B = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }, z = B[S], R = B[D], q = je(0, E[$], W[$]), V = v ? E[$] / 2 - j - q - z - O.mainAxis : M - q - z - O.mainAxis, K = v ? -E[$] / 2 + j + q + R + O.mainAxis : F + q + R + O.mainAxis, Q = e.elements.arrow && Ne(e.elements.arrow), X = Q ? "y" === y ? Q.clientTop || 0 : Q.clientLeft || 0 : 0, Y = null != (L = null == x ? void 0 : x[y]) ? L : 0, U = I + K - Y, G = je(f ? Ae(N, I + V - Y - X) : N, I, f ? we(P, U) : P);
                    A[y] = G, k[y] = G - I;
                }
                if (a) {
                    var J, Z = "x" === y ? qt : Qt, tt = "x" === y ? Vt : Kt, et = A[w], it = "y" === w ? "height" : "width", nt = et + g[Z], st = et - g[tt], ot = -1 !== [
                        qt,
                        Qt
                    ].indexOf(_), rt = null != (J = null == x ? void 0 : x[w]) ? J : 0, at = ot ? nt : et - E[it] - T[it] - rt + O.altAxis, lt = ot ? et + E[it] + T[it] - rt - O.altAxis : st, ct = f && ot ? function(t, e, i) {
                        var n = je(t, e, i);
                        return n > i ? i : n;
                    }(at, et, lt) : je(f ? at : nt, et, f ? lt : st);
                    A[w] = ct, k[w] = ct - et;
                }
                e.modifiersData[n] = k;
            }
        },
        requiresIfExists: [
            "offset"
        ]
    };
    function fi(t, e, i) {
        void 0 === i && (i = !1);
        var n, s, o = _e(e), r = _e(e) && function(t) {
            var e = t.getBoundingClientRect(), i = Ee(e.width) / t.offsetWidth || 1, n = Ee(e.height) / t.offsetHeight || 1;
            return 1 !== i || 1 !== n;
        }(e), a = De(e), l = Oe(t, r, i), c = {
            scrollLeft: 0,
            scrollTop: 0
        }, h = {
            x: 0,
            y: 0
        };
        return (o || !o && !i) && (("body" !== pe(e) || Je(a)) && (c = (n = e) !== me(n) && _e(n) ? {
            scrollLeft: (s = n).scrollLeft,
            scrollTop: s.scrollTop
        } : Ue(n)), _e(e) ? ((h = Oe(e, !0)).x += e.clientLeft, h.y += e.clientTop) : a && (h.x = Ge(a))), {
            x: l.left + c.scrollLeft - h.x,
            y: l.top + c.scrollTop - h.y,
            width: l.width,
            height: l.height
        };
    }
    function pi(t) {
        var e = new Map, i = new Set, n = [];
        function s(t) {
            i.add(t.name), [].concat(t.requires || [], t.requiresIfExists || []).forEach(function(t) {
                if (!i.has(t)) {
                    var n = e.get(t);
                    n && s(n);
                }
            }), n.push(t);
        }
        return t.forEach(function(t) {
            e.set(t.name, t);
        }), t.forEach(function(t) {
            i.has(t.name) || s(t);
        }), n;
    }
    var mi = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
    };
    function gi() {
        for(var t = arguments.length, e = new Array(t), i = 0; i < t; i++)e[i] = arguments[i];
        return !e.some(function(t) {
            return !(t && "function" == typeof t.getBoundingClientRect);
        });
    }
    function _i(t) {
        void 0 === t && (t = {});
        var e = t, i = e.defaultModifiers, n = void 0 === i ? [] : i, s = e.defaultOptions, o = void 0 === s ? mi : s;
        return function(t, e, i) {
            void 0 === i && (i = o);
            var s, r, a = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, mi, o),
                modifiersData: {},
                elements: {
                    reference: t,
                    popper: e
                },
                attributes: {},
                styles: {}
            }, l = [], c = !1, h = {
                state: a,
                setOptions: function(i) {
                    var s = "function" == typeof i ? i(a.options) : i;
                    d(), a.options = Object.assign({}, o, a.options, s), a.scrollParents = {
                        reference: ge(t) ? ti(t) : t.contextElement ? ti(t.contextElement) : [],
                        popper: ti(e)
                    };
                    var r, c, u = function(t) {
                        var e = pi(t);
                        return fe.reduce(function(t, i) {
                            return t.concat(e.filter(function(t) {
                                return t.phase === i;
                            }));
                        }, []);
                    }((r = [].concat(n, a.options.modifiers), c = r.reduce(function(t, e) {
                        var i = t[e.name];
                        return t[e.name] = i ? Object.assign({}, i, e, {
                            options: Object.assign({}, i.options, e.options),
                            data: Object.assign({}, i.data, e.data)
                        }) : e, t;
                    }, {}), Object.keys(c).map(function(t) {
                        return c[t];
                    })));
                    return a.orderedModifiers = u.filter(function(t) {
                        return t.enabled;
                    }), a.orderedModifiers.forEach(function(t) {
                        var e = t.name, i = t.options, n = void 0 === i ? {} : i, s = t.effect;
                        if ("function" == typeof s) {
                            var o = s({
                                state: a,
                                name: e,
                                instance: h,
                                options: n
                            });
                            l.push(o || function() {});
                        }
                    }), h.update();
                },
                forceUpdate: function() {
                    if (!c) {
                        var t = a.elements, e = t.reference, i = t.popper;
                        if (gi(e, i)) {
                            a.rects = {
                                reference: fi(e, Ne(i), "fixed" === a.options.strategy),
                                popper: xe(i)
                            }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach(function(t) {
                                return a.modifiersData[t.name] = Object.assign({}, t.data);
                            });
                            for(var n = 0; n < a.orderedModifiers.length; n++)if (!0 !== a.reset) {
                                var s = a.orderedModifiers[n], o = s.fn, r = s.options, l = void 0 === r ? {} : r, d = s.name;
                                "function" == typeof o && (a = o({
                                    state: a,
                                    options: l,
                                    name: d,
                                    instance: h
                                }) || a);
                            } else a.reset = !1, n = -1;
                        }
                    }
                },
                update: (s = function() {
                    return new Promise(function(t) {
                        h.forceUpdate(), t(a);
                    });
                }, function() {
                    return r || (r = new Promise(function(t) {
                        Promise.resolve().then(function() {
                            r = void 0, t(s());
                        });
                    })), r;
                }),
                destroy: function() {
                    d(), c = !0;
                }
            };
            if (!gi(t, e)) return h;
            function d() {
                l.forEach(function(t) {
                    return t();
                }), l = [];
            }
            return h.setOptions(i).then(function(t) {
                !c && i.onFirstUpdate && i.onFirstUpdate(t);
            }), h;
        };
    }
    var bi = _i(), vi = _i({
        defaultModifiers: [
            Ve,
            di,
            Re,
            ve
        ]
    }), yi = _i({
        defaultModifiers: [
            Ve,
            di,
            Re,
            ve,
            hi,
            ri,
            ui,
            He,
            ci
        ]
    });
    const wi = Object.freeze(Object.defineProperty({
        __proto__: null,
        afterMain: ce,
        afterRead: re,
        afterWrite: ue,
        applyStyles: ve,
        arrow: He,
        auto: Xt,
        basePlacements: Yt,
        beforeMain: ae,
        beforeRead: se,
        beforeWrite: he,
        bottom: Vt,
        clippingParents: Jt,
        computeStyles: Re,
        createPopper: yi,
        createPopperBase: bi,
        createPopperLite: vi,
        detectOverflow: si,
        end: Gt,
        eventListeners: Ve,
        flip: ri,
        hide: ci,
        left: Qt,
        main: le,
        modifierPhases: fe,
        offset: hi,
        placements: ne,
        popper: te,
        popperGenerator: _i,
        popperOffsets: di,
        preventOverflow: ui,
        read: oe,
        reference: ee,
        right: Kt,
        start: Ut,
        top: qt,
        variationPlacements: ie,
        viewport: Zt,
        write: de
    }, Symbol.toStringTag, {
        value: "Module"
    })), Ai = "dropdown", Ei = ".bs.dropdown", Ti = ".data-api", Ci = "ArrowUp", Oi = "ArrowDown", xi = `hide${Ei}`, ki = `hidden${Ei}`, Li = `show${Ei}`, Si = `shown${Ei}`, Di = `click${Ei}${Ti}`, $i = `keydown${Ei}${Ti}`, Ii = `keyup${Ei}${Ti}`, Ni = "show", Pi = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)', ji = `${Pi}.${Ni}`, Mi = ".dropdown-menu", Fi = p() ? "top-end" : "top-start", Hi = p() ? "top-start" : "top-end", Wi = p() ? "bottom-end" : "bottom-start", Bi = p() ? "bottom-start" : "bottom-end", zi = p() ? "left-start" : "right-start", Ri = p() ? "right-start" : "left-start", qi = {
        autoClose: !0,
        boundary: "clippingParents",
        display: "dynamic",
        offset: [
            0,
            2
        ],
        popperConfig: null,
        reference: "toggle"
    }, Vi = {
        autoClose: "(boolean|string)",
        boundary: "(string|element)",
        display: "string",
        offset: "(array|string|function)",
        popperConfig: "(null|object|function)",
        reference: "(string|element|object)"
    };
    class Ki extends W {
        constructor(t, e){
            super(t, e), this._popper = null, this._parent = this._element.parentNode, this._menu = z.next(this._element, Mi)[0] || z.prev(this._element, Mi)[0] || z.findOne(Mi, this._parent), this._inNavbar = this._detectNavbar();
        }
        static get Default() {
            return qi;
        }
        static get DefaultType() {
            return Vi;
        }
        static get NAME() {
            return Ai;
        }
        toggle() {
            return this._isShown() ? this.hide() : this.show();
        }
        show() {
            if (l(this._element) || this._isShown()) return;
            const t = {
                relatedTarget: this._element
            };
            if (!N.trigger(this._element, Li, t).defaultPrevented) {
                if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav")) for (const t of [].concat(...document.body.children))N.on(t, "mouseover", h);
                this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(Ni), this._element.classList.add(Ni), N.trigger(this._element, Si, t);
            }
        }
        hide() {
            if (l(this._element) || !this._isShown()) return;
            const t = {
                relatedTarget: this._element
            };
            this._completeHide(t);
        }
        dispose() {
            this._popper && this._popper.destroy(), super.dispose();
        }
        update() {
            this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
        }
        _completeHide(t) {
            if (!N.trigger(this._element, xi, t).defaultPrevented) {
                if ("ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children))N.off(t, "mouseover", h);
                this._popper && this._popper.destroy(), this._menu.classList.remove(Ni), this._element.classList.remove(Ni), this._element.setAttribute("aria-expanded", "false"), F.removeDataAttribute(this._menu, "popper"), N.trigger(this._element, ki, t);
            }
        }
        _getConfig(t) {
            if ("object" == typeof (t = super._getConfig(t)).reference && !o(t.reference) && "function" != typeof t.reference.getBoundingClientRect) throw new TypeError(`${Ai.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
            return t;
        }
        _createPopper() {
            if (void 0 === wi) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org/docs/v2/)");
            let t = this._element;
            "parent" === this._config.reference ? t = this._parent : o(this._config.reference) ? t = r(this._config.reference) : "object" == typeof this._config.reference && (t = this._config.reference);
            const e = this._getPopperConfig();
            this._popper = yi(t, this._menu, e);
        }
        _isShown() {
            return this._menu.classList.contains(Ni);
        }
        _getPlacement() {
            const t = this._parent;
            if (t.classList.contains("dropend")) return zi;
            if (t.classList.contains("dropstart")) return Ri;
            if (t.classList.contains("dropup-center")) return "top";
            if (t.classList.contains("dropdown-center")) return "bottom";
            const e = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
            return t.classList.contains("dropup") ? e ? Hi : Fi : e ? Bi : Wi;
        }
        _detectNavbar() {
            return null !== this._element.closest(".navbar");
        }
        _getOffset() {
            const { offset: t } = this._config;
            return "string" == typeof t ? t.split(",").map((t)=>Number.parseInt(t, 10)) : "function" == typeof t ? (e)=>t(e, this._element) : t;
        }
        _getPopperConfig() {
            const t = {
                placement: this._getPlacement(),
                modifiers: [
                    {
                        name: "preventOverflow",
                        options: {
                            boundary: this._config.boundary
                        }
                    },
                    {
                        name: "offset",
                        options: {
                            offset: this._getOffset()
                        }
                    }
                ]
            };
            return (this._inNavbar || "static" === this._config.display) && (F.setDataAttribute(this._menu, "popper", "static"), t.modifiers = [
                {
                    name: "applyStyles",
                    enabled: !1
                }
            ]), {
                ...t,
                ...g(this._config.popperConfig, [
                    void 0,
                    t
                ])
            };
        }
        _selectMenuItem({ key: t, target: e }) {
            const i = z.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter((t)=>a(t));
            i.length && b(i, e, t === Oi, !i.includes(e)).focus();
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = Ki.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                    e[t]();
                }
            });
        }
        static clearMenus(t) {
            if (2 === t.button || "keyup" === t.type && "Tab" !== t.key) return;
            const e = z.find(ji);
            for (const i of e){
                const e = Ki.getInstance(i);
                if (!e || !1 === e._config.autoClose) continue;
                const n = t.composedPath(), s = n.includes(e._menu);
                if (n.includes(e._element) || "inside" === e._config.autoClose && !s || "outside" === e._config.autoClose && s) continue;
                if (e._menu.contains(t.target) && ("keyup" === t.type && "Tab" === t.key || /input|select|option|textarea|form/i.test(t.target.tagName))) continue;
                const o = {
                    relatedTarget: e._element
                };
                "click" === t.type && (o.clickEvent = t), e._completeHide(o);
            }
        }
        static dataApiKeydownHandler(t) {
            const e = /input|textarea/i.test(t.target.tagName), i = "Escape" === t.key, n = [
                Ci,
                Oi
            ].includes(t.key);
            if (!n && !i) return;
            if (e && !i) return;
            t.preventDefault();
            const s = this.matches(Pi) ? this : z.prev(this, Pi)[0] || z.next(this, Pi)[0] || z.findOne(Pi, t.delegateTarget.parentNode), o = Ki.getOrCreateInstance(s);
            if (n) return t.stopPropagation(), o.show(), void o._selectMenuItem(t);
            o._isShown() && (t.stopPropagation(), o.hide(), s.focus());
        }
    }
    N.on(document, $i, Pi, Ki.dataApiKeydownHandler), N.on(document, $i, Mi, Ki.dataApiKeydownHandler), N.on(document, Di, Ki.clearMenus), N.on(document, Ii, Ki.clearMenus), N.on(document, Di, Pi, function(t) {
        t.preventDefault(), Ki.getOrCreateInstance(this).toggle();
    }), m(Ki);
    const Qi = "backdrop", Xi = "show", Yi = `mousedown.bs.${Qi}`, Ui = {
        className: "modal-backdrop",
        clickCallback: null,
        isAnimated: !1,
        isVisible: !0,
        rootElement: "body"
    }, Gi = {
        className: "string",
        clickCallback: "(function|null)",
        isAnimated: "boolean",
        isVisible: "boolean",
        rootElement: "(element|string)"
    };
    class Ji extends H {
        constructor(t){
            super(), this._config = this._getConfig(t), this._isAppended = !1, this._element = null;
        }
        static get Default() {
            return Ui;
        }
        static get DefaultType() {
            return Gi;
        }
        static get NAME() {
            return Qi;
        }
        show(t) {
            if (!this._config.isVisible) return void g(t);
            this._append();
            const e = this._getElement();
            this._config.isAnimated && d(e), e.classList.add(Xi), this._emulateAnimation(()=>{
                g(t);
            });
        }
        hide(t) {
            this._config.isVisible ? (this._getElement().classList.remove(Xi), this._emulateAnimation(()=>{
                this.dispose(), g(t);
            })) : g(t);
        }
        dispose() {
            this._isAppended && (N.off(this._element, Yi), this._element.remove(), this._isAppended = !1);
        }
        _getElement() {
            if (!this._element) {
                const t = document.createElement("div");
                t.className = this._config.className, this._config.isAnimated && t.classList.add("fade"), this._element = t;
            }
            return this._element;
        }
        _configAfterMerge(t) {
            return t.rootElement = r(t.rootElement), t;
        }
        _append() {
            if (this._isAppended) return;
            const t = this._getElement();
            this._config.rootElement.append(t), N.on(t, Yi, ()=>{
                g(this._config.clickCallback);
            }), this._isAppended = !0;
        }
        _emulateAnimation(t) {
            _(t, this._getElement(), this._config.isAnimated);
        }
    }
    const Zi = ".bs.focustrap", tn = `focusin${Zi}`, en = `keydown.tab${Zi}`, nn = "backward", sn = {
        autofocus: !0,
        trapElement: null
    }, on = {
        autofocus: "boolean",
        trapElement: "element"
    };
    class rn extends H {
        constructor(t){
            super(), this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null;
        }
        static get Default() {
            return sn;
        }
        static get DefaultType() {
            return on;
        }
        static get NAME() {
            return "focustrap";
        }
        activate() {
            this._isActive || (this._config.autofocus && this._config.trapElement.focus(), N.off(document, Zi), N.on(document, tn, (t)=>this._handleFocusin(t)), N.on(document, en, (t)=>this._handleKeydown(t)), this._isActive = !0);
        }
        deactivate() {
            this._isActive && (this._isActive = !1, N.off(document, Zi));
        }
        _handleFocusin(t) {
            const { trapElement: e } = this._config;
            if (t.target === document || t.target === e || e.contains(t.target)) return;
            const i = z.focusableChildren(e);
            0 === i.length ? e.focus() : this._lastTabNavDirection === nn ? i[i.length - 1].focus() : i[0].focus();
        }
        _handleKeydown(t) {
            "Tab" === t.key && (this._lastTabNavDirection = t.shiftKey ? nn : "forward");
        }
    }
    const an = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", ln = ".sticky-top", cn = "padding-right", hn = "margin-right";
    class dn {
        constructor(){
            this._element = document.body;
        }
        getWidth() {
            const t = document.documentElement.clientWidth;
            return Math.abs(window.innerWidth - t);
        }
        hide() {
            const t = this.getWidth();
            this._disableOverFlow(), this._setElementAttributes(this._element, cn, (e)=>e + t), this._setElementAttributes(an, cn, (e)=>e + t), this._setElementAttributes(ln, hn, (e)=>e - t);
        }
        reset() {
            this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, cn), this._resetElementAttributes(an, cn), this._resetElementAttributes(ln, hn);
        }
        isOverflowing() {
            return this.getWidth() > 0;
        }
        _disableOverFlow() {
            this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
        }
        _setElementAttributes(t, e, i) {
            const n = this.getWidth();
            this._applyManipulationCallback(t, (t)=>{
                if (t !== this._element && window.innerWidth > t.clientWidth + n) return;
                this._saveInitialAttribute(t, e);
                const s = window.getComputedStyle(t).getPropertyValue(e);
                t.style.setProperty(e, `${i(Number.parseFloat(s))}px`);
            });
        }
        _saveInitialAttribute(t, e) {
            const i = t.style.getPropertyValue(e);
            i && F.setDataAttribute(t, e, i);
        }
        _resetElementAttributes(t, e) {
            this._applyManipulationCallback(t, (t)=>{
                const i = F.getDataAttribute(t, e);
                null !== i ? (F.removeDataAttribute(t, e), t.style.setProperty(e, i)) : t.style.removeProperty(e);
            });
        }
        _applyManipulationCallback(t, e) {
            if (o(t)) e(t);
            else for (const i of z.find(t, this._element))e(i);
        }
    }
    const un = ".bs.modal", fn = `hide${un}`, pn = `hidePrevented${un}`, mn = `hidden${un}`, gn = `show${un}`, _n = `shown${un}`, bn = `resize${un}`, vn = `click.dismiss${un}`, yn = `mousedown.dismiss${un}`, wn = `keydown.dismiss${un}`, An = `click${un}.data-api`, En = "modal-open", Tn = "show", Cn = "modal-static", On = {
        backdrop: !0,
        focus: !0,
        keyboard: !0
    }, xn = {
        backdrop: "(boolean|string)",
        focus: "boolean",
        keyboard: "boolean"
    };
    class kn extends W {
        constructor(t, e){
            super(t, e), this._dialog = z.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new dn, this._addEventListeners();
        }
        static get Default() {
            return On;
        }
        static get DefaultType() {
            return xn;
        }
        static get NAME() {
            return "modal";
        }
        toggle(t) {
            return this._isShown ? this.hide() : this.show(t);
        }
        show(t) {
            this._isShown || this._isTransitioning || N.trigger(this._element, gn, {
                relatedTarget: t
            }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(En), this._adjustDialog(), this._backdrop.show(()=>this._showElement(t)));
        }
        hide() {
            this._isShown && !this._isTransitioning && (N.trigger(this._element, fn).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(Tn), this._queueCallback(()=>this._hideModal(), this._element, this._isAnimated())));
        }
        dispose() {
            N.off(window, un), N.off(this._dialog, un), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
        }
        handleUpdate() {
            this._adjustDialog();
        }
        _initializeBackDrop() {
            return new Ji({
                isVisible: Boolean(this._config.backdrop),
                isAnimated: this._isAnimated()
            });
        }
        _initializeFocusTrap() {
            return new rn({
                trapElement: this._element
            });
        }
        _showElement(t) {
            document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
            const e = z.findOne(".modal-body", this._dialog);
            e && (e.scrollTop = 0), d(this._element), this._element.classList.add(Tn), this._queueCallback(()=>{
                this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, N.trigger(this._element, _n, {
                    relatedTarget: t
                });
            }, this._dialog, this._isAnimated());
        }
        _addEventListeners() {
            N.on(this._element, wn, (t)=>{
                "Escape" === t.key && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition());
            }), N.on(window, bn, ()=>{
                this._isShown && !this._isTransitioning && this._adjustDialog();
            }), N.on(this._element, yn, (t)=>{
                N.one(this._element, vn, (e)=>{
                    this._element === t.target && this._element === e.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition());
                });
            });
        }
        _hideModal() {
            this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(()=>{
                document.body.classList.remove(En), this._resetAdjustments(), this._scrollBar.reset(), N.trigger(this._element, mn);
            });
        }
        _isAnimated() {
            return this._element.classList.contains("fade");
        }
        _triggerBackdropTransition() {
            if (N.trigger(this._element, pn).defaultPrevented) return;
            const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._element.style.overflowY;
            "hidden" === e || this._element.classList.contains(Cn) || (t || (this._element.style.overflowY = "hidden"), this._element.classList.add(Cn), this._queueCallback(()=>{
                this._element.classList.remove(Cn), this._queueCallback(()=>{
                    this._element.style.overflowY = e;
                }, this._dialog);
            }, this._dialog), this._element.focus());
        }
        _adjustDialog() {
            const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), i = e > 0;
            if (i && !t) {
                const t = p() ? "paddingLeft" : "paddingRight";
                this._element.style[t] = `${e}px`;
            }
            if (!i && t) {
                const t = p() ? "paddingRight" : "paddingLeft";
                this._element.style[t] = `${e}px`;
            }
        }
        _resetAdjustments() {
            this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
        }
        static jQueryInterface(t, e) {
            return this.each(function() {
                const i = kn.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
                    i[t](e);
                }
            });
        }
    }
    N.on(document, An, '[data-bs-toggle="modal"]', function(t) {
        const e = z.getElementFromSelector(this);
        [
            "A",
            "AREA"
        ].includes(this.tagName) && t.preventDefault(), N.one(e, gn, (t)=>{
            t.defaultPrevented || N.one(e, mn, ()=>{
                a(this) && this.focus();
            });
        });
        const i = z.findOne(".modal.show");
        i && kn.getInstance(i).hide(), kn.getOrCreateInstance(e).toggle(this);
    }), R(kn), m(kn);
    const Ln = ".bs.offcanvas", Sn = ".data-api", Dn = `load${Ln}${Sn}`, $n = "show", In = "showing", Nn = "hiding", Pn = ".offcanvas.show", jn = `show${Ln}`, Mn = `shown${Ln}`, Fn = `hide${Ln}`, Hn = `hidePrevented${Ln}`, Wn = `hidden${Ln}`, Bn = `resize${Ln}`, zn = `click${Ln}${Sn}`, Rn = `keydown.dismiss${Ln}`, qn = {
        backdrop: !0,
        keyboard: !0,
        scroll: !1
    }, Vn = {
        backdrop: "(boolean|string)",
        keyboard: "boolean",
        scroll: "boolean"
    };
    class Kn extends W {
        constructor(t, e){
            super(t, e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners();
        }
        static get Default() {
            return qn;
        }
        static get DefaultType() {
            return Vn;
        }
        static get NAME() {
            return "offcanvas";
        }
        toggle(t) {
            return this._isShown ? this.hide() : this.show(t);
        }
        show(t) {
            this._isShown || N.trigger(this._element, jn, {
                relatedTarget: t
            }).defaultPrevented || (this._isShown = !0, this._backdrop.show(), this._config.scroll || (new dn).hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(In), this._queueCallback(()=>{
                this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add($n), this._element.classList.remove(In), N.trigger(this._element, Mn, {
                    relatedTarget: t
                });
            }, this._element, !0));
        }
        hide() {
            this._isShown && (N.trigger(this._element, Fn).defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(Nn), this._backdrop.hide(), this._queueCallback(()=>{
                this._element.classList.remove($n, Nn), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || (new dn).reset(), N.trigger(this._element, Wn);
            }, this._element, !0)));
        }
        dispose() {
            this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
        }
        _initializeBackDrop() {
            const t = Boolean(this._config.backdrop);
            return new Ji({
                className: "offcanvas-backdrop",
                isVisible: t,
                isAnimated: !0,
                rootElement: this._element.parentNode,
                clickCallback: t ? ()=>{
                    "static" !== this._config.backdrop ? this.hide() : N.trigger(this._element, Hn);
                } : null
            });
        }
        _initializeFocusTrap() {
            return new rn({
                trapElement: this._element
            });
        }
        _addEventListeners() {
            N.on(this._element, Rn, (t)=>{
                "Escape" === t.key && (this._config.keyboard ? this.hide() : N.trigger(this._element, Hn));
            });
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = Kn.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                    e[t](this);
                }
            });
        }
    }
    N.on(document, zn, '[data-bs-toggle="offcanvas"]', function(t) {
        const e = z.getElementFromSelector(this);
        if ([
            "A",
            "AREA"
        ].includes(this.tagName) && t.preventDefault(), l(this)) return;
        N.one(e, Wn, ()=>{
            a(this) && this.focus();
        });
        const i = z.findOne(Pn);
        i && i !== e && Kn.getInstance(i).hide(), Kn.getOrCreateInstance(e).toggle(this);
    }), N.on(window, Dn, ()=>{
        for (const t of z.find(Pn))Kn.getOrCreateInstance(t).show();
    }), N.on(window, Bn, ()=>{
        for (const t of z.find("[aria-modal][class*=show][class*=offcanvas-]"))"fixed" !== getComputedStyle(t).position && Kn.getOrCreateInstance(t).hide();
    }), R(Kn), m(Kn);
    const Qn = {
        "*": [
            "class",
            "dir",
            "id",
            "lang",
            "role",
            /^aria-[\w-]*$/i
        ],
        a: [
            "target",
            "href",
            "title",
            "rel"
        ],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        dd: [],
        div: [],
        dl: [],
        dt: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: [
            "src",
            "srcset",
            "alt",
            "title",
            "width",
            "height"
        ],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: []
    }, Xn = new Set([
        "background",
        "cite",
        "href",
        "itemtype",
        "longdesc",
        "poster",
        "src",
        "xlink:href"
    ]), Yn = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, Un = (t, e)=>{
        const i = t.nodeName.toLowerCase();
        return e.includes(i) ? !Xn.has(i) || Boolean(Yn.test(t.nodeValue)) : e.filter((t)=>t instanceof RegExp).some((t)=>t.test(i));
    }, Gn = {
        allowList: Qn,
        content: {},
        extraClass: "",
        html: !1,
        sanitize: !0,
        sanitizeFn: null,
        template: "<div></div>"
    }, Jn = {
        allowList: "object",
        content: "object",
        extraClass: "(string|function)",
        html: "boolean",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        template: "string"
    }, Zn = {
        entry: "(string|element|function|null)",
        selector: "(string|element)"
    };
    class ts extends H {
        constructor(t){
            super(), this._config = this._getConfig(t);
        }
        static get Default() {
            return Gn;
        }
        static get DefaultType() {
            return Jn;
        }
        static get NAME() {
            return "TemplateFactory";
        }
        getContent() {
            return Object.values(this._config.content).map((t)=>this._resolvePossibleFunction(t)).filter(Boolean);
        }
        hasContent() {
            return this.getContent().length > 0;
        }
        changeContent(t) {
            return this._checkContent(t), this._config.content = {
                ...this._config.content,
                ...t
            }, this;
        }
        toHtml() {
            const t = document.createElement("div");
            t.innerHTML = this._maybeSanitize(this._config.template);
            for (const [e, i] of Object.entries(this._config.content))this._setContent(t, i, e);
            const e = t.children[0], i = this._resolvePossibleFunction(this._config.extraClass);
            return i && e.classList.add(...i.split(" ")), e;
        }
        _typeCheckConfig(t) {
            super._typeCheckConfig(t), this._checkContent(t.content);
        }
        _checkContent(t) {
            for (const [e, i] of Object.entries(t))super._typeCheckConfig({
                selector: e,
                entry: i
            }, Zn);
        }
        _setContent(t, e, i) {
            const n = z.findOne(i, t);
            n && ((e = this._resolvePossibleFunction(e)) ? o(e) ? this._putElementInTemplate(r(e), n) : this._config.html ? n.innerHTML = this._maybeSanitize(e) : n.textContent = e : n.remove());
        }
        _maybeSanitize(t) {
            return this._config.sanitize ? function(t, e, i) {
                if (!t.length) return t;
                if (i && "function" == typeof i) return i(t);
                const n = (new window.DOMParser).parseFromString(t, "text/html"), s = [].concat(...n.body.querySelectorAll("*"));
                for (const t of s){
                    const i = t.nodeName.toLowerCase();
                    if (!Object.keys(e).includes(i)) {
                        t.remove();
                        continue;
                    }
                    const n = [].concat(...t.attributes), s = [].concat(e["*"] || [], e[i] || []);
                    for (const e of n)Un(e, s) || t.removeAttribute(e.nodeName);
                }
                return n.body.innerHTML;
            }(t, this._config.allowList, this._config.sanitizeFn) : t;
        }
        _resolvePossibleFunction(t) {
            return g(t, [
                void 0,
                this
            ]);
        }
        _putElementInTemplate(t, e) {
            if (this._config.html) return e.innerHTML = "", void e.append(t);
            e.textContent = t.textContent;
        }
    }
    const es = new Set([
        "sanitize",
        "allowList",
        "sanitizeFn"
    ]), is = "fade", ns = "show", ss = ".tooltip-inner", os = ".modal", rs = "hide.bs.modal", as = "hover", ls = "focus", cs = {
        AUTO: "auto",
        TOP: "top",
        RIGHT: p() ? "left" : "right",
        BOTTOM: "bottom",
        LEFT: p() ? "right" : "left"
    }, hs = {
        allowList: Qn,
        animation: !0,
        boundary: "clippingParents",
        container: !1,
        customClass: "",
        delay: 0,
        fallbackPlacements: [
            "top",
            "right",
            "bottom",
            "left"
        ],
        html: !1,
        offset: [
            0,
            6
        ],
        placement: "top",
        popperConfig: null,
        sanitize: !0,
        sanitizeFn: null,
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        title: "",
        trigger: "hover focus"
    }, ds = {
        allowList: "object",
        animation: "boolean",
        boundary: "(string|element)",
        container: "(string|element|boolean)",
        customClass: "(string|function)",
        delay: "(number|object)",
        fallbackPlacements: "array",
        html: "boolean",
        offset: "(array|string|function)",
        placement: "(string|function)",
        popperConfig: "(null|object|function)",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        selector: "(string|boolean)",
        template: "string",
        title: "(string|element|function)",
        trigger: "string"
    };
    class us extends W {
        constructor(t, e){
            if (void 0 === wi) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org/docs/v2/)");
            super(t, e), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle();
        }
        static get Default() {
            return hs;
        }
        static get DefaultType() {
            return ds;
        }
        static get NAME() {
            return "tooltip";
        }
        enable() {
            this._isEnabled = !0;
        }
        disable() {
            this._isEnabled = !1;
        }
        toggleEnabled() {
            this._isEnabled = !this._isEnabled;
        }
        toggle() {
            this._isEnabled && (this._isShown() ? this._leave() : this._enter());
        }
        dispose() {
            clearTimeout(this._timeout), N.off(this._element.closest(os), rs, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose();
        }
        show() {
            if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
            if (!this._isWithContent() || !this._isEnabled) return;
            const t = N.trigger(this._element, this.constructor.eventName("show")), e = (c(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
            if (t.defaultPrevented || !e) return;
            this._disposePopper();
            const i = this._getTipElement();
            this._element.setAttribute("aria-describedby", i.getAttribute("id"));
            const { container: n } = this._config;
            if (this._element.ownerDocument.documentElement.contains(this.tip) || (n.append(i), N.trigger(this._element, this.constructor.eventName("inserted"))), this._popper = this._createPopper(i), i.classList.add(ns), "ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children))N.on(t, "mouseover", h);
            this._queueCallback(()=>{
                N.trigger(this._element, this.constructor.eventName("shown")), !1 === this._isHovered && this._leave(), this._isHovered = !1;
            }, this.tip, this._isAnimated());
        }
        hide() {
            if (this._isShown() && !N.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) {
                if (this._getTipElement().classList.remove(ns), "ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children))N.off(t, "mouseover", h);
                this._activeTrigger.click = !1, this._activeTrigger[ls] = !1, this._activeTrigger[as] = !1, this._isHovered = null, this._queueCallback(()=>{
                    this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), N.trigger(this._element, this.constructor.eventName("hidden")));
                }, this.tip, this._isAnimated());
            }
        }
        update() {
            this._popper && this._popper.update();
        }
        _isWithContent() {
            return Boolean(this._getTitle());
        }
        _getTipElement() {
            return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip;
        }
        _createTipElement(t) {
            const e = this._getTemplateFactory(t).toHtml();
            if (!e) return null;
            e.classList.remove(is, ns), e.classList.add(`bs-${this.constructor.NAME}-auto`);
            const i = ((t)=>{
                do {
                    t += Math.floor(1e6 * Math.random());
                }while (document.getElementById(t))
                return t;
            })(this.constructor.NAME).toString();
            return e.setAttribute("id", i), this._isAnimated() && e.classList.add(is), e;
        }
        setContent(t) {
            this._newContent = t, this._isShown() && (this._disposePopper(), this.show());
        }
        _getTemplateFactory(t) {
            return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new ts({
                ...this._config,
                content: t,
                extraClass: this._resolvePossibleFunction(this._config.customClass)
            }), this._templateFactory;
        }
        _getContentForTemplate() {
            return {
                [ss]: this._getTitle()
            };
        }
        _getTitle() {
            return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
        }
        _initializeOnDelegatedTarget(t) {
            return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig());
        }
        _isAnimated() {
            return this._config.animation || this.tip && this.tip.classList.contains(is);
        }
        _isShown() {
            return this.tip && this.tip.classList.contains(ns);
        }
        _createPopper(t) {
            const e = g(this._config.placement, [
                this,
                t,
                this._element
            ]), i = cs[e.toUpperCase()];
            return yi(this._element, t, this._getPopperConfig(i));
        }
        _getOffset() {
            const { offset: t } = this._config;
            return "string" == typeof t ? t.split(",").map((t)=>Number.parseInt(t, 10)) : "function" == typeof t ? (e)=>t(e, this._element) : t;
        }
        _resolvePossibleFunction(t) {
            return g(t, [
                this._element,
                this._element
            ]);
        }
        _getPopperConfig(t) {
            const e = {
                placement: t,
                modifiers: [
                    {
                        name: "flip",
                        options: {
                            fallbackPlacements: this._config.fallbackPlacements
                        }
                    },
                    {
                        name: "offset",
                        options: {
                            offset: this._getOffset()
                        }
                    },
                    {
                        name: "preventOverflow",
                        options: {
                            boundary: this._config.boundary
                        }
                    },
                    {
                        name: "arrow",
                        options: {
                            element: `.${this.constructor.NAME}-arrow`
                        }
                    },
                    {
                        name: "preSetPlacement",
                        enabled: !0,
                        phase: "beforeMain",
                        fn: (t)=>{
                            this._getTipElement().setAttribute("data-popper-placement", t.state.placement);
                        }
                    }
                ]
            };
            return {
                ...e,
                ...g(this._config.popperConfig, [
                    void 0,
                    e
                ])
            };
        }
        _setListeners() {
            const t = this._config.trigger.split(" ");
            for (const e of t)if ("click" === e) N.on(this._element, this.constructor.eventName("click"), this._config.selector, (t)=>{
                this._initializeOnDelegatedTarget(t).toggle();
            });
            else if ("manual" !== e) {
                const t = e === as ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"), i = e === as ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout");
                N.on(this._element, t, this._config.selector, (t)=>{
                    const e = this._initializeOnDelegatedTarget(t);
                    e._activeTrigger["focusin" === t.type ? ls : as] = !0, e._enter();
                }), N.on(this._element, i, this._config.selector, (t)=>{
                    const e = this._initializeOnDelegatedTarget(t);
                    e._activeTrigger["focusout" === t.type ? ls : as] = e._element.contains(t.relatedTarget), e._leave();
                });
            }
            this._hideModalHandler = ()=>{
                this._element && this.hide();
            }, N.on(this._element.closest(os), rs, this._hideModalHandler);
        }
        _fixTitle() {
            const t = this._element.getAttribute("title");
            t && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", t), this._element.setAttribute("data-bs-original-title", t), this._element.removeAttribute("title"));
        }
        _enter() {
            this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0, this._setTimeout(()=>{
                this._isHovered && this.show();
            }, this._config.delay.show));
        }
        _leave() {
            this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout(()=>{
                this._isHovered || this.hide();
            }, this._config.delay.hide));
        }
        _setTimeout(t, e) {
            clearTimeout(this._timeout), this._timeout = setTimeout(t, e);
        }
        _isWithActiveTrigger() {
            return Object.values(this._activeTrigger).includes(!0);
        }
        _getConfig(t) {
            const e = F.getDataAttributes(this._element);
            for (const t of Object.keys(e))es.has(t) && delete e[t];
            return t = {
                ...e,
                ..."object" == typeof t && t ? t : {}
            }, t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t;
        }
        _configAfterMerge(t) {
            return t.container = !1 === t.container ? document.body : r(t.container), "number" == typeof t.delay && (t.delay = {
                show: t.delay,
                hide: t.delay
            }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), t;
        }
        _getDelegateConfig() {
            const t = {};
            for (const [e, i] of Object.entries(this._config))this.constructor.Default[e] !== i && (t[e] = i);
            return t.selector = !1, t.trigger = "manual", t;
        }
        _disposePopper() {
            this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null);
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = us.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                    e[t]();
                }
            });
        }
    }
    m(us);
    const fs = ".popover-header", ps = ".popover-body", ms = {
        ...us.Default,
        content: "",
        offset: [
            0,
            8
        ],
        placement: "right",
        template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
        trigger: "click"
    }, gs = {
        ...us.DefaultType,
        content: "(null|string|element|function)"
    };
    class _s extends us {
        static get Default() {
            return ms;
        }
        static get DefaultType() {
            return gs;
        }
        static get NAME() {
            return "popover";
        }
        _isWithContent() {
            return this._getTitle() || this._getContent();
        }
        _getContentForTemplate() {
            return {
                [fs]: this._getTitle(),
                [ps]: this._getContent()
            };
        }
        _getContent() {
            return this._resolvePossibleFunction(this._config.content);
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = _s.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                    e[t]();
                }
            });
        }
    }
    m(_s);
    const bs = ".bs.scrollspy", vs = `activate${bs}`, ys = `click${bs}`, ws = `load${bs}.data-api`, As = "active", Es = "[href]", Ts = ".nav-link", Cs = `${Ts}, .nav-item > ${Ts}, .list-group-item`, Os = {
        offset: null,
        rootMargin: "0px 0px -25%",
        smoothScroll: !1,
        target: null,
        threshold: [
            .1,
            .5,
            1
        ]
    }, xs = {
        offset: "(number|null)",
        rootMargin: "string",
        smoothScroll: "boolean",
        target: "element",
        threshold: "array"
    };
    class ks extends W {
        constructor(t, e){
            super(t, e), this._targetLinks = new Map, this._observableSections = new Map, this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = {
                visibleEntryTop: 0,
                parentScrollTop: 0
            }, this.refresh();
        }
        static get Default() {
            return Os;
        }
        static get DefaultType() {
            return xs;
        }
        static get NAME() {
            return "scrollspy";
        }
        refresh() {
            this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
            for (const t of this._observableSections.values())this._observer.observe(t);
        }
        dispose() {
            this._observer.disconnect(), super.dispose();
        }
        _configAfterMerge(t) {
            return t.target = r(t.target) || document.body, t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin, "string" == typeof t.threshold && (t.threshold = t.threshold.split(",").map((t)=>Number.parseFloat(t))), t;
        }
        _maybeEnableSmoothScroll() {
            this._config.smoothScroll && (N.off(this._config.target, ys), N.on(this._config.target, ys, Es, (t)=>{
                const e = this._observableSections.get(t.target.hash);
                if (e) {
                    t.preventDefault();
                    const i = this._rootElement || window, n = e.offsetTop - this._element.offsetTop;
                    if (i.scrollTo) return void i.scrollTo({
                        top: n,
                        behavior: "smooth"
                    });
                    i.scrollTop = n;
                }
            }));
        }
        _getNewObserver() {
            const t = {
                root: this._rootElement,
                threshold: this._config.threshold,
                rootMargin: this._config.rootMargin
            };
            return new IntersectionObserver((t)=>this._observerCallback(t), t);
        }
        _observerCallback(t) {
            const e = (t)=>this._targetLinks.get(`#${t.target.id}`), i = (t)=>{
                this._previousScrollData.visibleEntryTop = t.target.offsetTop, this._process(e(t));
            }, n = (this._rootElement || document.documentElement).scrollTop, s = n >= this._previousScrollData.parentScrollTop;
            this._previousScrollData.parentScrollTop = n;
            for (const o of t){
                if (!o.isIntersecting) {
                    this._activeTarget = null, this._clearActiveClass(e(o));
                    continue;
                }
                const t = o.target.offsetTop >= this._previousScrollData.visibleEntryTop;
                if (s && t) {
                    if (i(o), !n) return;
                } else s || t || i(o);
            }
        }
        _initializeTargetsAndObservables() {
            this._targetLinks = new Map, this._observableSections = new Map;
            const t = z.find(Es, this._config.target);
            for (const e of t){
                if (!e.hash || l(e)) continue;
                const t = z.findOne(decodeURI(e.hash), this._element);
                a(t) && (this._targetLinks.set(decodeURI(e.hash), e), this._observableSections.set(e.hash, t));
            }
        }
        _process(t) {
            this._activeTarget !== t && (this._clearActiveClass(this._config.target), this._activeTarget = t, t.classList.add(As), this._activateParents(t), N.trigger(this._element, vs, {
                relatedTarget: t
            }));
        }
        _activateParents(t) {
            if (t.classList.contains("dropdown-item")) z.findOne(".dropdown-toggle", t.closest(".dropdown")).classList.add(As);
            else for (const e of z.parents(t, ".nav, .list-group"))for (const t of z.prev(e, Cs))t.classList.add(As);
        }
        _clearActiveClass(t) {
            t.classList.remove(As);
            const e = z.find(`${Es}.${As}`, t);
            for (const t of e)t.classList.remove(As);
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = ks.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                    e[t]();
                }
            });
        }
    }
    N.on(window, ws, ()=>{
        for (const t of z.find('[data-bs-spy="scroll"]'))ks.getOrCreateInstance(t);
    }), m(ks);
    const Ls = ".bs.tab", Ss = `hide${Ls}`, Ds = `hidden${Ls}`, $s = `show${Ls}`, Is = `shown${Ls}`, Ns = `click${Ls}`, Ps = `keydown${Ls}`, js = `load${Ls}`, Ms = "ArrowLeft", Fs = "ArrowRight", Hs = "ArrowUp", Ws = "ArrowDown", Bs = "Home", zs = "End", Rs = "active", qs = "fade", Vs = "show", Ks = ".dropdown-toggle", Qs = `:not(${Ks})`, Xs = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', Ys = `.nav-link${Qs}, .list-group-item${Qs}, [role="tab"]${Qs}, ${Xs}`, Us = `.${Rs}[data-bs-toggle="tab"], .${Rs}[data-bs-toggle="pill"], .${Rs}[data-bs-toggle="list"]`;
    class Gs extends W {
        constructor(t){
            super(t), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), N.on(this._element, Ps, (t)=>this._keydown(t)));
        }
        static get NAME() {
            return "tab";
        }
        show() {
            const t = this._element;
            if (this._elemIsActive(t)) return;
            const e = this._getActiveElem(), i = e ? N.trigger(e, Ss, {
                relatedTarget: t
            }) : null;
            N.trigger(t, $s, {
                relatedTarget: e
            }).defaultPrevented || i && i.defaultPrevented || (this._deactivate(e, t), this._activate(t, e));
        }
        _activate(t, e) {
            t && (t.classList.add(Rs), this._activate(z.getElementFromSelector(t)), this._queueCallback(()=>{
                "tab" === t.getAttribute("role") ? (t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), N.trigger(t, Is, {
                    relatedTarget: e
                })) : t.classList.add(Vs);
            }, t, t.classList.contains(qs)));
        }
        _deactivate(t, e) {
            t && (t.classList.remove(Rs), t.blur(), this._deactivate(z.getElementFromSelector(t)), this._queueCallback(()=>{
                "tab" === t.getAttribute("role") ? (t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), N.trigger(t, Ds, {
                    relatedTarget: e
                })) : t.classList.remove(Vs);
            }, t, t.classList.contains(qs)));
        }
        _keydown(t) {
            if (![
                Ms,
                Fs,
                Hs,
                Ws,
                Bs,
                zs
            ].includes(t.key)) return;
            t.stopPropagation(), t.preventDefault();
            const e = this._getChildren().filter((t)=>!l(t));
            let i;
            if ([
                Bs,
                zs
            ].includes(t.key)) i = e[t.key === Bs ? 0 : e.length - 1];
            else {
                const n = [
                    Fs,
                    Ws
                ].includes(t.key);
                i = b(e, t.target, n, !0);
            }
            i && (i.focus({
                preventScroll: !0
            }), Gs.getOrCreateInstance(i).show());
        }
        _getChildren() {
            return z.find(Ys, this._parent);
        }
        _getActiveElem() {
            return this._getChildren().find((t)=>this._elemIsActive(t)) || null;
        }
        _setInitialAttributes(t, e) {
            this._setAttributeIfNotExists(t, "role", "tablist");
            for (const t of e)this._setInitialAttributesOnChild(t);
        }
        _setInitialAttributesOnChild(t) {
            t = this._getInnerElement(t);
            const e = this._elemIsActive(t), i = this._getOuterElement(t);
            t.setAttribute("aria-selected", e), i !== t && this._setAttributeIfNotExists(i, "role", "presentation"), e || t.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t, "role", "tab"), this._setInitialAttributesOnTargetPanel(t);
        }
        _setInitialAttributesOnTargetPanel(t) {
            const e = z.getElementFromSelector(t);
            e && (this._setAttributeIfNotExists(e, "role", "tabpanel"), t.id && this._setAttributeIfNotExists(e, "aria-labelledby", `${t.id}`));
        }
        _toggleDropDown(t, e) {
            const i = this._getOuterElement(t);
            if (!i.classList.contains("dropdown")) return;
            const n = (t, n)=>{
                const s = z.findOne(t, i);
                s && s.classList.toggle(n, e);
            };
            n(Ks, Rs), n(".dropdown-menu", Vs), i.setAttribute("aria-expanded", e);
        }
        _setAttributeIfNotExists(t, e, i) {
            t.hasAttribute(e) || t.setAttribute(e, i);
        }
        _elemIsActive(t) {
            return t.classList.contains(Rs);
        }
        _getInnerElement(t) {
            return t.matches(Ys) ? t : z.findOne(Ys, t);
        }
        _getOuterElement(t) {
            return t.closest(".nav-item, .list-group-item") || t;
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = Gs.getOrCreateInstance(this);
                if ("string" == typeof t) {
                    if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                    e[t]();
                }
            });
        }
    }
    N.on(document, Ns, Xs, function(t) {
        [
            "A",
            "AREA"
        ].includes(this.tagName) && t.preventDefault(), l(this) || Gs.getOrCreateInstance(this).show();
    }), N.on(window, js, ()=>{
        for (const t of z.find(Us))Gs.getOrCreateInstance(t);
    }), m(Gs);
    const Js = ".bs.toast", Zs = `mouseover${Js}`, to = `mouseout${Js}`, eo = `focusin${Js}`, io = `focusout${Js}`, no = `hide${Js}`, so = `hidden${Js}`, oo = `show${Js}`, ro = `shown${Js}`, ao = "hide", lo = "show", co = "showing", ho = {
        animation: "boolean",
        autohide: "boolean",
        delay: "number"
    }, uo = {
        animation: !0,
        autohide: !0,
        delay: 5e3
    };
    class fo extends W {
        constructor(t, e){
            super(t, e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners();
        }
        static get Default() {
            return uo;
        }
        static get DefaultType() {
            return ho;
        }
        static get NAME() {
            return "toast";
        }
        show() {
            N.trigger(this._element, oo).defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove(ao), d(this._element), this._element.classList.add(lo, co), this._queueCallback(()=>{
                this._element.classList.remove(co), N.trigger(this._element, ro), this._maybeScheduleHide();
            }, this._element, this._config.animation));
        }
        hide() {
            this.isShown() && (N.trigger(this._element, no).defaultPrevented || (this._element.classList.add(co), this._queueCallback(()=>{
                this._element.classList.add(ao), this._element.classList.remove(co, lo), N.trigger(this._element, so);
            }, this._element, this._config.animation)));
        }
        dispose() {
            this._clearTimeout(), this.isShown() && this._element.classList.remove(lo), super.dispose();
        }
        isShown() {
            return this._element.classList.contains(lo);
        }
        _maybeScheduleHide() {
            this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(()=>{
                this.hide();
            }, this._config.delay)));
        }
        _onInteraction(t, e) {
            switch(t.type){
                case "mouseover":
                case "mouseout":
                    this._hasMouseInteraction = e;
                    break;
                case "focusin":
                case "focusout":
                    this._hasKeyboardInteraction = e;
            }
            if (e) return void this._clearTimeout();
            const i = t.relatedTarget;
            this._element === i || this._element.contains(i) || this._maybeScheduleHide();
        }
        _setListeners() {
            N.on(this._element, Zs, (t)=>this._onInteraction(t, !0)), N.on(this._element, to, (t)=>this._onInteraction(t, !1)), N.on(this._element, eo, (t)=>this._onInteraction(t, !0)), N.on(this._element, io, (t)=>this._onInteraction(t, !1));
        }
        _clearTimeout() {
            clearTimeout(this._timeout), this._timeout = null;
        }
        static jQueryInterface(t) {
            return this.each(function() {
                const e = fo.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                    e[t](this);
                }
            });
        }
    }
    return R(fo), m(fo), {
        Alert: Q,
        Button: Y,
        Carousel: Lt,
        Collapse: Rt,
        Dropdown: Ki,
        Modal: kn,
        Offcanvas: Kn,
        Popover: _s,
        ScrollSpy: ks,
        Tab: Gs,
        Toast: fo,
        Tooltip: us
    };
}); //# sourceMappingURL=bootstrap.bundle.min.js.map
}}),

};

//# sourceMappingURL=node_modules_02a1a02a._.js.map